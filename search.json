[
  {
    "objectID": "async.html#async-sdk",
    "href": "async.html#async-sdk",
    "title": "The async version",
    "section": "Async SDK",
    "text": "Async SDK\n\nmodel = models[1]\ncli = AsyncAnthropic()\n\n\nm = {'role': 'user', 'content': \"I'm Jeremy\"}\nr = await cli.messages.create(messages=[m], model=model, max_tokens=100)\nr\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_019gsEQs5dqb3kgwNJbTH27M\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 36}\n\n\n\n\n\nsource\n\nAsyncClient\n\n AsyncClient (model, cli=None, log=False)\n\nAsync Anthropic messages client.\n\n\nExported source\nclass AsyncClient(Client):\n    def __init__(self, model, cli=None, log=False):\n        \"Async Anthropic messages client.\"\n        super().__init__(model,cli,log)\n        if not cli: self.c = AsyncAnthropic(default_headers={'anthropic-beta': 'prompt-caching-2024-07-31'})\n\n\n\nc = AsyncClient(model)\n\n\nc._r(r)\nc.use\n\nIn: 10; Out: 36; Total: 46\n\n\n\nsource\n\n\nAsyncClient.__call__\n\n AsyncClient.__call__ (msgs:list, sp='', temp=0, maxtok=4096, prefill='',\n                       stream:bool=False, stop=None, cli=None, log=False)\n\nMake an async call to Claude.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmsgs\nlist\n\nList of messages in the dialog\n\n\nsp\nstr\n\nThe system prompt\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nstream\nbool\nFalse\nStream response?\n\n\nstop\nNoneType\nNone\nStop sequence\n\n\ncli\nNoneType\nNone\n\n\n\nlog\nbool\nFalse\n\n\n\n\n\n\nExported source\n@patch\nasync def _stream(self:AsyncClient, msgs:list, prefill='', **kwargs):\n    async with self.c.messages.stream(model=self.model, messages=mk_msgs(msgs), **kwargs) as s:\n        if prefill: yield prefill\n        async for o in s.text_stream: yield o\n        self._log(await s.get_final_message(), prefill, msgs, kwargs)\n\n\n\n\nExported source\n@patch\n@delegates(Client)\nasync def __call__(self:AsyncClient,\n             msgs:list, # List of messages in the dialog\n             sp='', # The system prompt\n             temp=0, # Temperature\n             maxtok=4096, # Maximum tokens\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             stream:bool=False, # Stream response?\n             stop=None, # Stop sequence\n             **kwargs):\n    \"Make an async call to Claude.\"\n    msgs = self._precall(msgs, prefill, stop, kwargs)\n    if stream: return self._stream(msgs, prefill=prefill, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    res = await self.c.messages.create(\n        model=self.model, messages=msgs, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    return self._log(res, prefill, msgs, maxtok, sp, temp, stream=stream, stop=stop, **kwargs)\n\n\n\nc = AsyncClient(model, log=True)\nc.use\n\nIn: 0; Out: 0; Total: 0\n\n\n\nc.model = models[1]\nawait c('Hi')\n\nHello! How can I assist you today? Feel free to ask any questions or let me know if you need help with anything.\n\n\nid: msg_01L9vqP9r1LcmvSk8vWGLbPo\ncontent: [{'text': 'Hello! How can I assist you today? Feel free to ask any questions or let me know if you need help with anything.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 8, 'output_tokens': 29, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nc.use\n\nIn: 8; Out: 29; Total: 37\n\n\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\nawait c(q, prefill=pref)\n\nAccording to Douglas Adams, the meaning of life is 42. More seriously, there’s no universally agreed upon meaning of life. Many philosophers and religions have proposed different answers, but it remains an open question that individuals must grapple with for themselves.\n\n\nid: msg_01KAJbCneA2oCRPVm9EkyDXF\ncontent: [{'text': \"According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon meaning of life. Many philosophers and religions have proposed different answers, but it remains an open question that individuals must grapple with for themselves.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 24, 'output_tokens': 51, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nasync for o in (await c('Hi', stream=True)): print(o, end='')\n\nHello! How can I assist you today? Feel free to ask any questions or let me know if you need help with anything.\n\n\n\nc.use\n\nIn: 40; Out: 109; Total: 149\n\n\n\nasync for o in (await c(q, prefill=pref, stream=True)): print(o, end='')\n\nAccording to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon meaning of life. Many philosophers and religions have proposed different answers, but it remains an open question that individuals must grapple with for themselves.\n\n\n\nc.use\n\nIn: 64; Out: 160; Total: 224\n\n\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\n\na,b = 604542,6458932\npr = f\"What is {a}+{b}?\"\nsp = \"You are a summing expert.\"\n\n\ntools=[get_schema(sums)]\nchoice = mk_tool_choice('sums')\n\n\ntools = [get_schema(sums)]\nmsgs = mk_msgs(pr)\nr = await c(msgs, sp=sp, tools=tools, tool_choice=choice)\ntr = mk_toolres(r, ns=globals())\nmsgs += tr\ncontents(await c(msgs, sp=sp, tools=tools))\n\nFinding the sum of 604542 and 6458932\n\n\n'As a summing expert, I\\'m happy to help you with this addition. The sum of 604542 and 6458932 is 7063474.\\n\\nTo break it down:\\n604542 (first number)\\n+ 6458932 (second number)\\n= 7063474 (total sum)\\n\\nThis result was calculated using the \"sums\" function, which adds two numbers together. Is there anything else you\\'d like me to sum for you?'",
    "crumbs": [
      "The async version"
    ]
  },
  {
    "objectID": "async.html#asyncchat",
    "href": "async.html#asyncchat",
    "title": "The async version",
    "section": "AsyncChat",
    "text": "AsyncChat\n\nsource\n\nAsyncChat\n\n AsyncChat (model:Optional[str]=None,\n            cli:Optional[claudette.core.Client]=None, sp='',\n            tools:Optional[list]=None, cont_pr:Optional[str]=None,\n            tool_choice:Optional[dict]=None)\n\nAnthropic async chat client.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmodel\nOptional\nNone\nModel to use (leave empty if passing cli)\n\n\ncli\nOptional\nNone\nClient to use (leave empty if passing model)\n\n\nsp\nstr\n\n\n\n\ntools\nOptional\nNone\n\n\n\ncont_pr\nOptional\nNone\n\n\n\ntool_choice\nOptional\nNone\n\n\n\n\n\n\nExported source\n@delegates()\nclass AsyncChat(Chat):\n    def __init__(self,\n                 model:Optional[str]=None, # Model to use (leave empty if passing `cli`)\n                 cli:Optional[Client]=None, # Client to use (leave empty if passing `model`)\n                 **kwargs):\n        \"Anthropic async chat client.\"\n        super().__init__(model, cli, **kwargs)\n        if not cli: self.c = AsyncClient(model)\n\n\n\nsp = \"Never mention what tools you use.\"\nchat = AsyncChat(model, sp=sp)\nchat.c.use, chat.h\n\n(In: 0; Out: 0; Total: 0, [])\n\n\n\nsource\n\n\nAsyncChat.__call__\n\n AsyncChat.__call__ (pr=None, temp=0, maxtok=4096, stream=False,\n                     prefill='', **kw)\n\nCall self as a function.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npr\nNoneType\nNone\nPrompt / message\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nstream\nbool\nFalse\nStream response?\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nkw\n\n\n\n\n\n\n\n\nExported source\n@patch\nasync def _stream(self:AsyncChat, res):\n    async for o in res: yield o\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n\n\n\n\nExported source\n@patch\nasync def _append_pr(self:AsyncChat, pr=None):\n    prev_role = nested_idx(self.h, -1, 'role') if self.h else 'assistant' # First message should be 'user' if no history\n    if pr and prev_role == 'user': await self()\n    self._post_pr(pr, prev_role)\n\n\n\n\nExported source\n@patch\nasync def __call__(self:AsyncChat,\n        pr=None,  # Prompt / message\n        temp=0, # Temperature\n        maxtok=4096, # Maximum tokens\n        stream=False, # Stream response?\n        prefill='', # Optional prefill to pass to Claude as start of its response\n        **kw):\n    await self._append_pr(pr)\n    if self.tools: kw['tools'] = [get_schema(o) for o in self.tools]\n    if self.tool_choice and pr: kw['tool_choice'] = mk_tool_choice(self.tool_choice)\n    res = await self.c(self.h, stream=stream, prefill=prefill, sp=self.sp, temp=temp, maxtok=maxtok, **kw)\n    if stream: return self._stream(res)\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n    return res\n\n\n\nawait chat(\"I'm Jeremy\")\nawait chat(\"What's my name?\")\n\nYour name is Jeremy, as you mentioned in your previous message.\n\n\nid: msg_01NMugMXWpDP9iuTXeLkHarn\ncontent: [{'text': 'Your name is Jeremy, as you mentioned in your previous message.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 64, 'output_tokens': 16, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\nawait chat(q, prefill=pref)\n\nAccording to Douglas Adams, the meaning of life is 42. More seriously, there’s no universally agreed upon answer. Common philosophical perspectives include:\n\nFinding personal fulfillment\nServing others\nPursuing happiness\nCreating meaning through our choices\nExperiencing and appreciating existence\n\nUltimately, many believe each individual must determine their own life’s meaning.\n\n\nid: msg_01VPWUQn5Do1Kst8RYUDQvCu\ncontent: [{'text': \"According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common philosophical perspectives include:\\n\\n1. Finding personal fulfillment\\n2. Serving others\\n3. Pursuing happiness\\n4. Creating meaning through our choices\\n5. Experiencing and appreciating existence\\n\\nUltimately, many believe each individual must determine their own life's meaning.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 100, 'output_tokens': 82, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nchat = AsyncChat(model, sp=sp)\nasync for o in (await chat(\"I'm Jeremy\", stream=True)): print(o, end='')\n\nHello Jeremy! It's nice to meet you. How are you doing today? Is there anything in particular you'd like to chat about or any questions I can help you with?\n\n\n\npr = f\"What is {a}+{b}?\"\nchat = AsyncChat(model, sp=sp, tools=[sums])\nr = await chat(pr)\nr\n\nFinding the sum of 604542 and 6458932\n\n\nTo answer this question, I can use the “sums” function to add these two numbers together. Let me do that for you.\n\n\nid: msg_015z1rffSWFxvj7rSpzc43ZE\ncontent: [{'text': 'To answer this question, I can use the \"sums\" function to add these two numbers together. Let me do that for you.', 'type': 'text'}, {'id': 'toolu_01SNKhtfnDQBC4RGY4mUCq1v', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 428, 'output_tokens': 101, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nawait chat()\n\nThe sum of 604542 and 6458932 is 7063474.\n\n\nid: msg_018KAsE2YGiXWjUJkLPrXpb2\ncontent: [{'text': 'The sum of 604542 and 6458932 is 7063474.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 543, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nfn = Path('samples/puppy.jpg')\nimg = fn.read_bytes()\n\n\nq = \"In brief, what color flowers are in this image?\"\nmsg = mk_msg([img_msg(img), text_msg(q)])\nawait c([msg])\n\nThe flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple daisy, blooming in the background behind the adorable puppy in the foreground.\n\n\nid: msg_017qgZggLjUY915mWbWCkb9X\ncontent: [{'text': 'The flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple daisy, blooming in the background behind the adorable puppy in the foreground.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 110, 'output_tokens': 50, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}",
    "crumbs": [
      "The async version"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "claudette",
    "section": "",
    "text": "NB: If you are reading this in GitHub’s readme, we recommend you instead read the much more nicely formatted documentation format of this tutorial.\nClaudette is a wrapper for Anthropic’s Python SDK.\nThe SDK works well, but it is quite low level – it leaves the developer to do a lot of stuff manually. That’s a lot of extra work and boilerplate! Claudette automates pretty much everything that can be automated, whilst providing full control. Amongst the features provided:\nYou’ll need to set the ANTHROPIC_API_KEY environment variable to the key provided to you by Anthropic in order to use this library.\nNote that this library is the first ever “literate nbdev” project. That means that the actual source code for the library is a rendered Jupyter Notebook which includes callout notes and tips, HTML tables and images, detailed explanations, and teaches how and why the code is written the way it is. Even if you’ve never used the Anthropic Python SDK or Claude API before, you should be able to read the source code. Click Claudette’s Source to read it, or clone the git repo and execute the notebook yourself to see every step of the creation process in action. The tutorial below includes links to API details which will take you to relevant parts of the source. The reason this project is a new kind of literal program is because we take seriously Knuth’s call to action, that we have a “moral commitment” to never write an “illiterate program” – and so we have a commitment to making literate programming and easy and pleasant experience. (For more on this, see this talk from Hamel Husain.)",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "claudette",
    "section": "Install",
    "text": "Install\npip install claudette",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "claudette",
    "section": "Getting started",
    "text": "Getting started\nAnthropic’s Python SDK will automatically be installed with Claudette, if you don’t already have it.\n\nimport os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\n\nTo print every HTTP request and response in full, uncomment the above line.\n\nfrom claudette import *\n\nClaudette only exports the symbols that are needed to use the library, so you can use import * to import them. Alternatively, just use:\nimport claudette\n…and then add the prefix claudette. to any usages of the module.\nClaudette provides models, which is a list of models currently available from the SDK.\n\nmodels\n\n('claude-3-opus-20240229',\n 'claude-3-5-sonnet-20240620',\n 'claude-3-haiku-20240307')\n\n\nFor these examples, we’ll use Sonnet 3.5, since it’s awesome!\n\nmodel = models[1]",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#chat",
    "href": "index.html#chat",
    "title": "claudette",
    "section": "Chat",
    "text": "Chat\nThe main interface to Claudette is the Chat class, which provides a stateful interface to Claude:\n\nchat = Chat(model, sp=\"\"\"You are a helpful and concise assistant.\"\"\")\nchat(\"I'm Jeremy\")\n\nHello Jeremy, it’s nice to meet you. How can I assist you today?\n\n\nid: msg_01WUaYx8YVsxPX5YtjYkyEF7\ncontent: [{'text': \"Hello Jeremy, it's nice to meet you. How can I assist you today?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 19, 'output_tokens': 20, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nr = chat(\"What's my name?\")\nr\n\nYour name is Jeremy, as you just told me.\n\n\nid: msg_01TBJC55GiRs5fq1mKRhyhxZ\ncontent: [{'text': 'Your name is Jeremy, as you just told me.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 47, 'output_tokens': 14, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nAs you see above, displaying the results of a call in a notebook shows just the message contents, with the other details hidden behind a collapsible section. Alternatively you can print the details:\n\nprint(r)\n\nMessage(id='msg_01TBJC55GiRs5fq1mKRhyhxZ', content=[TextBlock(text='Your name is Jeremy, as you just told me.', type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=In: 47; Out: 14; Total: 61)\n\n\nClaude supports adding an extra assistant message at the end, which contains the prefill – i.e. the text we want Claude to assume the response starts with. Let’s try it out:\n\nchat(\"Concisely, what is the meaning of life?\",\n     prefill='According to Douglas Adams,')\n\nAccording to Douglas Adams, “42.” More seriously, it’s often considered to be finding personal fulfillment, happiness, and purpose.\n\n\nid: msg_01QbBGFJcX4NzUqS4cGPnXbu\ncontent: [{'text': 'According to Douglas Adams,  \"42.\" More seriously, it\\'s often considered to be finding personal fulfillment, happiness, and purpose.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 81, 'output_tokens': 27, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nYou can add stream=True to stream the results as soon as they arrive (although you will only see the gradual generation if you execute the notebook yourself, of course!)\n\nfor o in chat(\"Concisely, what book was that in?\", prefill='It was in', stream=True):\n    print(o, end='')\n\nIt was in \"The Hitchhiker's Guide to the Galaxy\" by Douglas Adams.\n\n\n\nAsync\nAlternatively, you can use AsyncChat (or AsyncClient) for the async versions, e.g:\n\nchat = AsyncChat(model)\nawait chat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_015H4DsD8q4hhts7bs7LxaCQ\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 36, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nRemember to use async for when streaming in this case:\n\nasync for o in await chat(\"Concisely, what is the meaning of life?\",\n                          prefill='According to Douglas Adams,', stream=True):\n    print(o, end='')\n\nAccording to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common perspectives include:\n\n1. Finding personal happiness and fulfillment\n2. Serving others or a higher purpose\n3. Creating meaning through our choices and actions\n4. Experiencing and appreciating existence\n5. Evolving and growing as individuals and as a species\n\nUltimately, many believe each person must define their own meaning of life.",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#prompt-caching",
    "href": "index.html#prompt-caching",
    "title": "claudette",
    "section": "Prompt caching",
    "text": "Prompt caching\nIf you use mk_msg(msg, cache=True), then the message is cached using Claude’s prompt caching feature. For instance, here we use caching when asking about Claudette’s readme file:\n\nchat = Chat(model, sp=\"\"\"You are a helpful and concise assistant.\"\"\")\n\n\nnbtxt = Path('README.txt').read_text()\nmsg = f'''&lt;README&gt;\n{nbtxt}\n&lt;/README&gt;\nIn brief, what is the purpose of this project based on the readme?'''\nr = chat(mk_msg(msg, cache=True))\nr\n\nBased on the readme, the main purpose of the Claudette project is to provide a high-level wrapper around Anthropic’s Python SDK for interacting with Claude AI models. Key features and goals include:\n\nAutomating and simplifying interactions with Claude, reducing boilerplate code.\nProviding a stateful dialog interface through the Chat class.\nSupporting features like prefill (specifying the start of Claude’s response) and image handling.\nOffering convenient support for Claude’s Tool Use API.\nServing as an example of “literate programming”, with the source code designed to be readable and educational, including explanations of how and why the code is written.\nSupporting multiple model providers, including direct Anthropic API access as well as Claude models available through Amazon Bedrock and Google Vertex AI.\n\nThe project aims to make working with Claude models more convenient and accessible for developers while also serving as an educational resource on how to effectively use and interact with these AI models.\n\n\nid: msg_01HkjoKjfY5zrmBrkjHvtDpG\ncontent: [{'text': 'Based on the readme, the main purpose of the Claudette project is to provide a high-level wrapper around Anthropic\\'s Python SDK for interacting with Claude AI models. Key features and goals include:\\n\\n1. Automating and simplifying interactions with Claude, reducing boilerplate code.\\n\\n2. Providing a stateful dialog interface through the [Chat](https://claudette.answer.ai/core.html#chat) class.\\n\\n3. Supporting features like prefill (specifying the start of Claude\\'s response) and image handling.\\n\\n4. Offering convenient support for Claude\\'s Tool Use API.\\n\\n5. Serving as an example of \"literate programming\", with the source code designed to be readable and educational, including explanations of how and why the code is written.\\n\\n6. Supporting multiple model providers, including direct Anthropic API access as well as Claude models available through Amazon Bedrock and Google Vertex AI.\\n\\nThe project aims to make working with Claude models more convenient and accessible for developers while also serving as an educational resource on how to effectively use and interact with these AI models.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 4, 'output_tokens': 220, 'cache_creation_input_tokens': 7171, 'cache_read_input_tokens': 0}\n\n\n\n\nThe response records the a cache has been created using these input tokens:\n\nprint(r.usage)\n\nUsage(input_tokens=4, output_tokens=220, cache_creation_input_tokens=7171, cache_read_input_tokens=0)\n\n\nWe can now ask a followup question in this chat:\n\nr = chat('How does it make tool use more ergonomic?')\nr\n\nClaudette makes tool use more ergonomic in several ways:\n\nSimplified function definition: It uses docments to make defining Python functions for tools as simple as possible. Each parameter and the return value should have a type and a description.\nAutomatic handling: The Chat class can be initialized with a list of tools, and Claudette handles the back-and-forth between Claude and the tools automatically.\nSingle-step execution: The Chat.toolloop method allows for executing a series of tool calls in a single step, even if multiple tools are needed to solve a problem.\nForced tool use: You can set tool_choice to force Claude to always answer using a specific tool.\nTracing: The toolloop method supports a trace_func parameter, allowing you to see each response from Claude during the process.\nAutomatic parameter passing: When Claude decides to use a tool, Claudette automatically calls the tool with the provided parameters.\nSystem prompt integration: It allows setting a system prompt to guide Claude’s behavior when using tools, such as instructing it not to mention the tools it’s using.\n\nThese features significantly reduce the amount of code and manual handling required to use Claude’s tool use capabilities, making the process more streamlined and developer-friendly.\n\n\nid: msg_01EfFbEBeYETAvfjGncn8Vcb\ncontent: [{'text': \"Claudette makes tool use more ergonomic in several ways:\\n\\n1. Simplified function definition: It uses docments to make defining Python functions for tools as simple as possible. Each parameter and the return value should have a type and a description.\\n\\n2. Automatic handling: The [Chat](https://claudette.answer.ai/core.html#chat) class can be initialized with a list of tools, and Claudette handles the back-and-forth between Claude and the tools automatically.\\n\\n3. Single-step execution: The [Chat.toolloop](https://claudette.answer.ai/toolloop.html#chat.toolloop) method allows for executing a series of tool calls in a single step, even if multiple tools are needed to solve a problem.\\n\\n4. Forced tool use: You can settool_choiceto force Claude to always answer using a specific tool.\\n\\n5. Tracing: Thetoolloopmethod supports atrace_funcparameter, allowing you to see each response from Claude during the process.\\n\\n6. Automatic parameter passing: When Claude decides to use a tool, Claudette automatically calls the tool with the provided parameters.\\n\\n7. System prompt integration: It allows setting a system prompt to guide Claude's behavior when using tools, such as instructing it not to mention the tools it's using.\\n\\nThese features significantly reduce the amount of code and manual handling required to use Claude's tool use capabilities, making the process more streamlined and developer-friendly.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 240, 'output_tokens': 289, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 7171}\n\n\n\n\nWe can see that this only used ~200 regular input tokens – the 7000+ context tokens have been read from cache.\n\nprint(r.usage)\n\nUsage(input_tokens=240, output_tokens=289, cache_creation_input_tokens=0, cache_read_input_tokens=7171)",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#tool-use",
    "href": "index.html#tool-use",
    "title": "claudette",
    "section": "Tool use",
    "text": "Tool use\nTool use lets Claude use external tools.\nWe use docments to make defining Python functions as ergonomic as possible. Each parameter (and the return value) should have a type, and a docments comment with the description of what it is. As an example we’ll write a simple function that adds numbers together, and will tell us when it’s being called:\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\nSometimes Claude will say something like “according to the sums tool the answer is” – generally we’d rather it just tells the user the answer, so we can use a system prompt to help with this:\n\nsp = \"Never mention what tools you use.\"\n\nWe’ll get Claude to add up some long numbers:\n\na,b = 604542,6458932\npr = f\"What is {a}+{b}?\"\npr\n\n'What is 604542+6458932?'\n\n\nTo use tools, pass a list of them to Chat, and to force it to always answer using a tool, set tool_choice to that function name:\n\nchat = Chat(model, sp=sp, tools=[sums], tool_choice='sums')\n\nNow when we call that with our prompt, Claude doesn’t return the answer, but instead returns a tool_use message, which means we have to call the named tool with the provided parameters:\n\nr = chat(pr)\nr\n\nFinding the sum of 604542 and 6458932\n\n\nToolUseBlock(id=‘toolu_01C6G2iuLtBBftESiujKzXfx’, input={‘a’: 604542, ‘b’: 6458932}, name=‘sums’, type=‘tool_use’)\n\n\nid: msg_01HPZwX3mQ7sMbjWUHEwgUsT\ncontent: [{'id': 'toolu_01C6G2iuLtBBftESiujKzXfx', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 414, 'output_tokens': 53, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nClaudette handles all that for us – we just call it again, and it all happens automatically:\n\nchat()\n\nThe sum of 604542 and 6458932 is 7063474.\n\n\nid: msg_01RNHxf1jXfS76h2UpF8RnZ2\ncontent: [{'text': 'The sum of 604542 and 6458932 is 7063474.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 515, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nYou can see how many tokens have been used at any time by checking the use property. Note that (as of May 2024) tool use in Claude uses a lot of tokens, since it automatically adds a large system prompt.\n\nchat.use\n\nIn: 929; Out: 76; Total: 1005\n\n\nWe can do everything needed to use tools in a single step, by using Chat.toolloop. This can even call multiple tools as needed solve a problem. For example, let’s define a tool to handle multiplication:\n\ndef mults(\n    a:int,  # First thing to multiply\n    b:int=1 # Second thing to multiply\n) -&gt; int: # The product of the inputs\n    \"Multiplies a * b.\"\n    print(f\"Finding the product of {a} and {b}\")\n    return a * b\n\nNow with a single call we can calculate (a+b)*2 – by passing show_trace we can see each response from Claude in the process:\n\nchat = Chat(model, sp=sp, tools=[sums,mults])\npr = f'Calculate ({a}+{b})*2'\npr\n\n'Calculate (604542+6458932)*2'\n\n\n\nchat.toolloop(pr, trace_func=print)\n\nFinding the sum of 604542 and 6458932\nMessage(id='msg_01DgZ9Fcs6h8HB7qEaFkg3Ah', content=[TextBlock(text='Certainly! To calculate (604542+6458932)*2, we\\'ll need to use the available tools to perform the addition and multiplication operations. Let\\'s break it down step by step:\\n\\n1. First, we\\'ll add 604542 and 6458932 using the \"sums\" function.\\n2. Then, we\\'ll multiply the result by 2 using the \"mults\" function.\\n\\nLet\\'s start with the addition:', type='text'), ToolUseBlock(id='toolu_01XTMLyKo9Q6TX4SpCVmmUsP', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='tool_use', stop_sequence=None, type='message', usage=In: 538; Out: 168; Total: 706)\nFinding the product of 7063474 and 2\nMessage(id='msg_011P8jdxwLoKNf8nTDua7VM8', content=[TextBlock(text=\"Great! The sum of 604542 and 6458932 is 7063474.\\n\\nNow, let's multiply this result by 2:\", type='text'), ToolUseBlock(id='toolu_01FETWkj4a9HyX25c8ETULYh', input={'a': 7063474, 'b': 2}, name='mults', type='tool_use')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='tool_use', stop_sequence=None, type='message', usage=In: 721; Out: 106; Total: 827)\nMessage(id='msg_01UXwy69vUWSy9bK24skQ3yE', content=[TextBlock(text='Now we have our final result. \\n\\nThe calculation (604542+6458932)*2 equals 14126948.\\n\\nTo break it down:\\n1. 604542 + 6458932 = 7063474\\n2. 7063474 * 2 = 14126948\\n\\nSo, the final answer to (604542+6458932)*2 is 14126948.', type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=In: 841; Out: 95; Total: 936)\n\n\nNow we have our final result.\nThe calculation (604542+6458932)*2 equals 14126948.\nTo break it down: 1. 604542 + 6458932 = 7063474 2. 7063474 * 2 = 14126948\nSo, the final answer to (604542+6458932)*2 is 14126948.\n\n\nid: msg_01UXwy69vUWSy9bK24skQ3yE\ncontent: [{'text': 'Now we have our final result. \\n\\nThe calculation (604542+6458932)*2 equals 14126948.\\n\\nTo break it down:\\n1. 604542 + 6458932 = 7063474\\n2. 7063474 * 2 = 14126948\\n\\nSo, the final answer to (604542+6458932)*2 is 14126948.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 841, 'output_tokens': 95, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#images",
    "href": "index.html#images",
    "title": "claudette",
    "section": "Images",
    "text": "Images\nClaude can handle image data as well. As everyone knows, when testing image APIs you have to use a cute puppy.\n\nfn = Path('samples/puppy.jpg')\ndisplay.Image(filename=fn, width=200)\n\n\n\n\n\n\n\n\nWe create a Chat object as before:\n\nchat = Chat(model)\n\nClaudette expects images as a list of bytes, so we read in the file:\n\nimg = fn.read_bytes()\n\nPrompts to Claudette can be lists, containing text, images, or both, eg:\n\nchat([img, \"In brief, what color flowers are in this image?\"])\n\nThe flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple daisy, blooming in the background behind the adorable puppy in the foreground.\n\n\nid: msg_01XtkdWMWHVppHqtiv7gdmtA\ncontent: [{'text': 'The flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple daisy, blooming in the background behind the adorable puppy in the foreground.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 110, 'output_tokens': 50, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nThe image is included as input tokens.\n\nchat.use\n\nIn: 110; Out: 50; Total: 160\n\n\nAlternatively, Claudette supports creating a multi-stage chat with separate image and text prompts. For instance, you can pass just the image as the initial prompt (in which case Claude will make some general comments about what it sees), and then follow up with questions in additional prompts:\n\nchat = Chat(model)\nchat(img)\n\nThis image shows an adorable puppy lying in the grass. The puppy appears to be a Cavalier King Charles Spaniel or a similar breed, with distinctive white and reddish-brown fur coloring. Its face is predominantly white with large, expressive eyes and a small black nose.\nThe puppy is resting on a grassy surface, and behind it, you can see some purple flowers, likely asters or michaelmas daisies. These flowers provide a lovely contrast to the puppy’s fur colors. In the background, there seems to be a wooden structure, possibly a fence or the side of a building, giving the scene a rustic, outdoor feel.\nThe composition of the image is quite charming, with the puppy as the main focus in the foreground and the flowers adding a soft, colorful backdrop. The lighting appears natural, highlighting the puppy’s soft fur and the delicate petals of the flowers. Overall, it’s a heartwarming scene that captures the innocence and cuteness of a young dog in a picturesque outdoor setting.\n\n\nid: msg_01Simo36wFes3M21SXZFGBT2\ncontent: [{'text': \"This image shows an adorable puppy lying in the grass. The puppy appears to be a Cavalier King Charles Spaniel or a similar breed, with distinctive white and reddish-brown fur coloring. Its face is predominantly white with large, expressive eyes and a small black nose.\\n\\nThe puppy is resting on a grassy surface, and behind it, you can see some purple flowers, likely asters or michaelmas daisies. These flowers provide a lovely contrast to the puppy's fur colors. In the background, there seems to be a wooden structure, possibly a fence or the side of a building, giving the scene a rustic, outdoor feel.\\n\\nThe composition of the image is quite charming, with the puppy as the main focus in the foreground and the flowers adding a soft, colorful backdrop. The lighting appears natural, highlighting the puppy's soft fur and the delicate petals of the flowers. Overall, it's a heartwarming scene that captures the innocence and cuteness of a young dog in a picturesque outdoor setting.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 98, 'output_tokens': 232, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nchat('What direction is the puppy facing?')\n\nThe puppy in the image is facing towards the left side of the frame. Its head is turned slightly, allowing us to see most of its face, including both eyes, its nose, and part of its mouth. The puppy’s body is angled diagonally, with its front paws visible and resting on the grass. This positioning gives the viewer a good look at the puppy’s adorable facial features and the distinctive coloring of its fur, while also creating an engaging composition within the photograph.\n\n\nid: msg_019YhPzDxXXjrcpjaS6G8fmF\ncontent: [{'text': \"The puppy in the image is facing towards the left side of the frame. Its head is turned slightly, allowing us to see most of its face, including both eyes, its nose, and part of its mouth. The puppy's body is angled diagonally, with its front paws visible and resting on the grass. This positioning gives the viewer a good look at the puppy's adorable facial features and the distinctive coloring of its fur, while also creating an engaging composition within the photograph.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 341, 'output_tokens': 108, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nchat('What color is it?')\n\nThe puppy in the image has a combination of two main colors:\n\nWhite: The majority of its face, including the area around its eyes, muzzle, and part of its chest, is white.\nReddish-brown: This color, often referred to as “chestnut” or “ruby” in Cavalier King Charles Spaniels, covers the puppy’s ears and extends to patches on its body.\n\nThe contrast between these two colors is quite striking and typical of the Cavalier King Charles Spaniel breed. The white fur appears bright and clean, while the reddish-brown areas have a rich, warm tone. This color combination, along with the puppy’s expressive eyes and small black nose, contributes to its incredibly cute and appealing appearance.\n\n\nid: msg_01WVxHA2sAff5q1En3q9km8F\ncontent: [{'text': 'The puppy in the image has a combination of two main colors:\\n\\n1. White: The majority of its face, including the area around its eyes, muzzle, and part of its chest, is white.\\n\\n2. Reddish-brown: This color, often referred to as \"chestnut\" or \"ruby\" in Cavalier King Charles Spaniels, covers the puppy\\'s ears and extends to patches on its body.\\n\\nThe contrast between these two colors is quite striking and typical of the Cavalier King Charles Spaniel breed. The white fur appears bright and clean, while the reddish-brown areas have a rich, warm tone. This color combination, along with the puppy\\'s expressive eyes and small black nose, contributes to its incredibly cute and appealing appearance.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 457, 'output_tokens': 175, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nNote that the image is passed in again for every input in the dialog, so that number of input tokens increases quickly with this kind of chat. (For large images, using prompt caching might be a good idea.)\n\nchat.use\n\nIn: 896; Out: 515; Total: 1411",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#other-model-providers",
    "href": "index.html#other-model-providers",
    "title": "claudette",
    "section": "Other model providers",
    "text": "Other model providers\nYou can also use 3rd party providers of Anthropic models, as shown here.\n\nAmazon Bedrock\nThese are the models available through Bedrock:\n\nmodels_aws\n\n('anthropic.claude-3-haiku-20240307-v1:0',\n 'anthropic.claude-3-sonnet-20240229-v1:0',\n 'anthropic.claude-3-opus-20240229-v1:0',\n 'anthropic.claude-3-5-sonnet-20240620-v1:0')\n\n\nTo use them, call AnthropicBedrock with your access details, and pass that to Client:\n\nfrom anthropic import AnthropicBedrock\n\n\nab = AnthropicBedrock(\n    aws_access_key=os.environ['AWS_ACCESS_KEY'],\n    aws_secret_key=os.environ['AWS_SECRET_KEY'],\n)\nclient = Client(models_aws[-1], ab)\n\nNow create your Chat object passing this client to the cli parameter – and from then on, everything is identical to the previous examples.\n\nchat = Chat(cli=client)\nchat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_bdrk_01VFVE1Pe5LNubaWYKC1sz8f\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 36}\n\n\n\n\n\n\nGoogle Vertex\nThese are the models available through Vertex:\n\nmodels_goog\n\n('claude-3-haiku@20240307',\n 'claude-3-sonnet@20240229',\n 'claude-3-opus@20240229',\n 'claude-3-5-sonnet@20240620')\n\n\nTo use them, call AnthropicVertex with your access details, and pass that to Client:\n\nfrom anthropic import AnthropicVertex\nimport google.auth\n\n\nproject_id = google.auth.default()[1]\ngv = AnthropicVertex(project_id=project_id, region=\"us-east5\")\nclient = Client(models_goog[-1], gv)\n\n\nchat = Chat(cli=client)\nchat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_vrtx_01P251BUJXBBvihsvb3VVgZ3\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 36}",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "toolloop.html",
    "href": "toolloop.html",
    "title": "Tool loop",
    "section": "",
    "text": "import os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\nmodel = models[-1]\nAnthropic provides an interesting example of using tools to mock up a hypothetical ordering system. We’re going to take it a step further, and show how we can dramatically simplify the process, whilst completing more complex tasks.\nWe’ll start by defining the same mock customer/order data as in Anthropic’s example, plus create a entity relationship between customers and orders:\norders = {\n    \"O1\": dict(id=\"O1\", product=\"Widget A\", quantity=2, price=19.99, status=\"Shipped\"),\n    \"O2\": dict(id=\"O2\", product=\"Gadget B\", quantity=1, price=49.99, status=\"Processing\"),\n    \"O3\": dict(id=\"O3\", product=\"Gadget B\", quantity=2, price=49.99, status=\"Shipped\")}\n\ncustomers = {\n    \"C1\": dict(name=\"John Doe\", email=\"john@example.com\", phone=\"123-456-7890\",\n               orders=[orders['O1'], orders['O2']]),\n    \"C2\": dict(name=\"Jane Smith\", email=\"jane@example.com\", phone=\"987-654-3210\",\n               orders=[orders['O3']])\n}\nWe can now define the same functions from the original example – but note that we don’t need to manually create the large JSON schema, since Claudette handles all that for us automatically from the functions directly. We’ll add some extra functionality to update order details when cancelling too.\ndef get_customer_info(\n    customer_id:str # ID of the customer\n): # Customer's name, email, phone number, and list of orders\n    \"Retrieves a customer's information and their orders based on the customer ID\"\n    print(f'- Retrieving customer {customer_id}')\n    return customers.get(customer_id, \"Customer not found\")\n\ndef get_order_details(\n    order_id:str # ID of the order\n): # Order's ID, product name, quantity, price, and order status\n    \"Retrieves the details of a specific order based on the order ID\"\n    print(f'- Retrieving order {order_id}')\n    return orders.get(order_id, \"Order not found\")\n\ndef cancel_order(\n    order_id:str # ID of the order to cancel\n)-&gt;bool: # True if the cancellation is successful\n    \"Cancels an order based on the provided order ID\"\n    print(f'- Cancelling order {order_id}')\n    if order_id not in orders: return False\n    orders[order_id]['status'] = 'Cancelled'\n    return True\nWe’re now ready to start our chat.\ntools = [get_customer_info, get_order_details, cancel_order]\nchat = Chat(model, tools=tools)\nWe’ll start with the same request as Anthropic showed:\nr = chat('Can you tell me the email address for customer C1?')\nprint(r.stop_reason)\nr.content\n\n- Retrieving customer C1\ntool_use\n\n\n[ToolUseBlock(id='toolu_01HTEcAfuuP7P9zhn77gKtkE', input={'customer_id': 'C1'}, name='get_customer_info', type='tool_use')]\nClaude asks us to use a tool. Claudette handles that automatically by just calling it again:\nr = chat()\ncontents(r)\n\n'The email address for customer C1 is john@example.com.'\nLet’s consider a more complex case than in the original example – what happens if a customer wants to cancel all of their orders?\nchat = Chat(model, tools=tools)\nr = chat('Please cancel all orders for customer C1 for me.')\nprint(r.stop_reason)\nr.content\n\n- Retrieving customer C1\ntool_use\n\n\n[TextBlock(text=\"Okay, let's cancel all orders for customer C1:\", type='text'),\n ToolUseBlock(id='toolu_017DZK1nviVow6deBvjLYQVZ', input={'customer_id': 'C1'}, name='get_customer_info', type='tool_use')]\nThis is the start of a multi-stage tool use process. Doing it manually step by step is inconvenient, so let’s write a function to handle this for us:\nsource",
    "crumbs": [
      "Tool loop"
    ]
  },
  {
    "objectID": "toolloop.html#code-interpreter",
    "href": "toolloop.html#code-interpreter",
    "title": "Tool loop",
    "section": "Code interpreter",
    "text": "Code interpreter\nHere is an example of using toolloop to implement a simple code interpreter with additional tools.\n\nfrom toolslm.shell import get_shell\nfrom fastcore.meta import delegates\nimport traceback\n\n\n@delegates()\nclass CodeChat(Chat):\n    imps = 'os, warnings, time, json, re, math, collections, itertools, functools, dateutil, datetime, string, types, copy, pprint, enum, numbers, decimal, fractions, random, operator, typing, dataclasses'\n    def __init__(self, model: Optional[str] = None, ask:bool=True, **kwargs):\n        super().__init__(model=model, **kwargs)\n        self.ask = ask\n        self.tools.append(self.run_cell)\n        self.shell = get_shell()\n        self.shell.run_cell('import '+self.imps)\n\nWe have one additional parameter to creating a CodeChat beyond what we pass to Chat, which is ask – if that’s True, we’ll prompt the user before running code.\n\n@patch\ndef run_cell(\n    self:CodeChat,\n    code:str,   # Code to execute in persistent IPython session\n): # Result of expression on last line (if exists); '#DECLINED#' if user declines request to execute\n    \"Asks user for permission, and if provided, executes python `code` using persistent IPython session.\"\n    confirm = f'Press Enter to execute, or enter \"n\" to skip?\\n```\\n{code}\\n```\\n'\n    if self.ask and input(confirm): return '#DECLINED#'\n    try: res = self.shell.run_cell(code)\n    except Exception as e: return traceback.format_exc()\n    return res.stdout if res.result is None else res.result\n\nWe just pass along requests to run code to the shell’s implementation. Claude often prints results instead of just using the last expression, so we capture stdout in those cases.\n\nsp = f'''You are a knowledgable assistant. Do not use tools unless needed.\nDon't do complex calculations yourself -- use code for them.\nThe following modules are pre-imported for `run_cell` automatically:\n\n{CodeChat.imps}\n\nNever mention what tools you are using. Note that `run_cell` interpreter state is *persistent* across calls.\n\nIf a tool returns `#DECLINED#` report to the user that the attempt was declined and no further progress can be made.'''\n\n\ndef get_user(ignored:str='' # Unused parameter\n            ): # Username of current user\n    \"Get the username of the user running this session\"\n    return 'Jeremy'\n\nIn order to test out multi-stage tool use, we create a mock function that Claude can call to get the current username.\n\nmodel = models[-1]\n\n\nchat = CodeChat(model, tools=[get_user], sp=sp, ask=True)\n\nClaude gets confused sometimes about how tools work, so we use examples to remind it:\n\nchat.h = [\n    'Calculate the square root of `10332`', 'math.sqrt(10332)',\n    '#DECLINED#', 'I am sorry but the request to execute that was declined and no further progress can be made.'\n]\n\nProviding a callable to toolloop’s trace_func lets us print out information during the loop:\n\ndef _show_cts(r):\n    for o in r.content:\n        if hasattr(o,'text'): print(o.text)\n        nm = getattr(o, 'name', None)\n        if nm=='run_cell': print(o.input['code'])\n        elif nm: print(f'{o.name}({o.input})')\n\n…and toolloop’s cont_func callable let’s us provide a function which, if it returns False, stops the loop:\n\ndef _cont_decline(c):\n    return nested_idx(c, 'content', 'content') != '#DECLINED#'\n\nNow we can try our code interpreter. We start by asking for a function to be created, which we’ll use in the next prompt to test that the interpreter is persistent.\n\npr = '''Create a 1-line function `checksum` for a string `s`,\nthat multiplies together the ascii values of each character in `s` using `reduce`.'''\nchat.toolloop(pr, temp=0.2, trace_func=_show_cts, cont_func=_cont_decline)\n\nPress Enter to execute, or enter \"n\" to skip?\n```\nfrom functools import reduce\n\ndef checksum(s):\n    return reduce(lambda x, y: x * ord(y), s, 1)\n```\n \n\n\nHere is a 1-line function to calculate the checksum of a string using `reduce` and multiplying the ASCII values of the characters:\nfrom functools import reduce\n\ndef checksum(s):\n    return reduce(lambda x, y: x * ord(y), s, 1)\n\n\nPress Enter to execute, or enter \"n\" to skip?\n```\nprint(checksum(\"hello\"))\n```\n \n\n\nTo test it:\nprint(checksum(\"hello\"))\nThe key steps are:\n\n1. Import `reduce` from `functools` to use the `reduce()` function.\n2. Define the `checksum()` function that takes a string `s` as input.\n3. Use `reduce()` to multiply the ASCII values (`ord(y)`) of each character `y` in the string `s`, starting with an initial value of 1.\n\nThis provides a concise one-line implementation of the checksum calculation using the `reduce()` function.\n\n\nThe key steps are:\n\nImport reduce from functools to use the reduce() function.\nDefine the checksum() function that takes a string s as input.\nUse reduce() to multiply the ASCII values (ord(y)) of each character y in the string s, starting with an initial value of 1.\n\nThis provides a concise one-line implementation of the checksum calculation using the reduce() function.\n\n\nid: msg_01HPVguuAVn2P7Fiqf5bu3Ap\ncontent: [{‘text’: ‘The key steps are:. Import reduce from functools to use the reduce() function.. Define the checksum() function that takes a string s as input.. Use reduce() to multiply the ASCII values (ord(y)) of each character y in the string s, starting with an initial value of 1.provides a concise one-line implementation of the checksum calculation using the reduce() function.’, ‘type’: ‘text’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 880, ‘output_tokens’: 114}\n\n\n\n\nBy asking for a calculation to be done on the username, we force it to use multiple steps:\n\npr = 'Use it to get the checksum of the username of this session.'\nchat.toolloop(pr, temp=0.2, trace_func=_show_cts)\n\nOkay, let's get the checksum of the username for this session:\nget_user({'ignored': 'ignored'})\n\n\nPress Enter to execute, or enter \"n\" to skip?\n```\nfrom functools import reduce\n\ndef checksum(s):\n    return reduce(lambda x, y: x * ord(y), s, 1)\n\nprint(checksum(\"Jeremy\"))\n```\n \n\n\nfrom functools import reduce\n\ndef checksum(s):\n    return reduce(lambda x, y: x * ord(y), s, 1)\n\nprint(checksum(\"Jeremy\"))\nThe checksum of the username \"Jeremy\" is 1134987783204.\n\n\nThe checksum of the username “Jeremy” is 1134987783204.\n\n\nid: msg_011VDiCPXRHa2XkkyS1hGEPB\ncontent: [{‘text’: ‘The checksum of the username “Jeremy” is 1134987783204.’, ‘type’: ‘text’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 1204, ‘output_tokens’: 21}",
    "crumbs": [
      "Tool loop"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Claudette’s source",
    "section": "",
    "text": "This is the ‘literate’ source code for Claudette. You can view the fully rendered version of the notebook here, or you can clone the git repo and run the interactive notebook in Jupyter. The notebook is converted the Python module claudette/core.py using nbdev. The goal of this source code is to both create the Python module, and also to teach the reader how it is created, without assuming much existing knowledge about Claude’s API.\nMost of the time you’ll see that we write some source code first, and then a description or discussion of it afterwards.",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#setup",
    "href": "core.html#setup",
    "title": "Claudette’s source",
    "section": "Setup",
    "text": "Setup\n\nimport os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\n\nTo print every HTTP request and response in full, uncomment the above line. This functionality is provided by Anthropic’s SDK.\n\n\n\n\n\n\nTip\n\n\n\nIf you’re reading the rendered version of this notebook, you’ll see an “Exported source” collapsible widget below. If you’re reading the source notebook directly, you’ll see #| exports at the top of the cell. These show that this piece of code will be exported into the python module that this notebook creates. No other code will be included – any other code in this notebook is just for demonstration, documentation, and testing.\nYou can toggle expanding/collapsing the source code of all exported sections by using the &lt;/&gt; Code menu in the top right of the rendered notebook page.\n\n\n\n\nExported source\nmodels = 'claude-3-opus-20240229','claude-3-5-sonnet-20240620','claude-3-haiku-20240307'\n\n\nThese are the current versions of Anthropic’s model at the time of writing.\n\nmodel = models[1]\n\nFor examples, we’ll use Sonnet 3.5, since it’s awesome.",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#antropic-sdk",
    "href": "core.html#antropic-sdk",
    "title": "Claudette’s source",
    "section": "Antropic SDK",
    "text": "Antropic SDK\n\ncli = Anthropic()\n\nThis is what Anthropic’s SDK provides for interacting with Python. To use it, pass it a list of messages, with content and a role. The roles should alternate between user and assistant.\n\n\n\n\n\n\nTip\n\n\n\nAfter the code below you’ll see an indented section with an orange vertical line on the left. This is used to show the result of running the code above. Because the code is running in a Jupyter Notebook, we don’t have to use print to display results, we can just type the expression directly, as we do with r here.\n\n\n\nm = {'role': 'user', 'content': \"I'm Jeremy\"}\nr = cli.messages.create(messages=[m], model=model, max_tokens=100)\nr\n\nMessage(id='msg_019qLJxay5HTSe8krZkYDgoV', content=[TextBlock(text=\"Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?\", type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=Usage(input_tokens=10, output_tokens=23))\n\n\n\nFormatting output\nThat output is pretty long and hard to read, so let’s clean it up. We’ll start by pulling out the Content part of the message. To do that, we’re going to write our first function which will be included to the claudette/core.py module.\n\n\n\n\n\n\nTip\n\n\n\nThis is the first exported public function or class we’re creating (the previous export was of a variable). In the rendered version of the notebook for these you’ll see 4 things, in this order (unless the symbol starts with a single _, which indicates it’s private):\n\nThe signature (with the symbol name as a heading, with a horizontal rule above)\nA table of paramater docs (if provided)\nThe doc string (in italics).\nThe source code (in a collapsible “Exported source” block)\n\nAfter that, we generally provide a bit more detail on what we’ve created, and why, along with a sample usage.\n\n\n\nsource\n\n\nfind_block\n\n find_block (r:collections.abc.Mapping, blk_type:type=&lt;class\n             'anthropic.types.text_block.TextBlock'&gt;)\n\nFind the first block of type blk_type in r.content.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nr\nMapping\n\nThe message to look in\n\n\nblk_type\ntype\nTextBlock\nThe type of block to find\n\n\n\n\n\nExported source\ndef find_block(r:abc.Mapping, # The message to look in\n               blk_type:type=TextBlock  # The type of block to find\n              ):\n    \"Find the first block of type `blk_type` in `r.content`.\"\n    return first(o for o in r.content if isinstance(o,blk_type))\n\n\nThis makes it easier to grab the needed parts of Claude’s responses, which can include multiple pieces of content. By default, we look for the first text block. That will generally have the content we want to display.\n\nfind_block(r)\n\nTextBlock(text=\"Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?\", type='text')\n\n\n\nsource\n\n\ncontents\n\n contents (r)\n\nHelper to get the contents from Claude response r.\n\n\nExported source\ndef contents(r):\n    \"Helper to get the contents from Claude response `r`.\"\n    blk = find_block(r)\n    if not blk and r.content: blk = r.content[0]\n    return blk.text.strip() if hasattr(blk,'text') else blk\n\n\nFor display purposes, we often just want to show the text itself.\n\ncontents(r)\n\n\"Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?\"\n\n\n\n\nExported source\n@patch\ndef _repr_markdown_(self:(Message)):\n    det = '\\n- '.join(f'{k}: `{v}`' for k,v in self.model_dump().items())\n    return f\"\"\"{contents(self)}\n\n&lt;details&gt;\n\n- {det}\n\n&lt;/details&gt;\"\"\"\n\n\nJupyter looks for a _repr_markdown_ method in displayed objects; we add this in order to display just the content text, and collapse full details into a hideable section. Note that patch is from fastcore, and is used to add (or replace) functionality in an existing class. We pass the class(es) that we want to patch as type annotations to self. In this case, _repr_markdown_ is being added to Anthropic’s Message class, so when we display the message now we just see the contents, and the details are hidden away in a collapsible details block.\n\nr\n\nHello Jeremy! It’s nice to meet you. Is there anything I can help you with today?\n\n\nid: msg_019qLJxay5HTSe8krZkYDgoV\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 23}\n\n\n\n\nOne key part of the response is the usage key, which tells us how many tokens we used by returning a Usage object.\nWe’ll add some helpers to make things a bit cleaner for creating and formatting these objects.\n\nr.usage\n\nUsage(input_tokens=10, output_tokens=23)\n\n\n\nsource\n\n\nusage\n\n usage (inp=0, out=0)\n\nSlightly more concise version of Usage.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninp\nint\n0\nNumber of input tokens\n\n\nout\nint\n0\nNumber of output tokens\n\n\n\n\n\nExported source\ndef usage(inp=0, # Number of input tokens\n          out=0  # Number of output tokens\n         ):\n    \"Slightly more concise version of `Usage`.\"\n    return Usage(input_tokens=inp, output_tokens=out)\n\n\nThe constructor provided by Anthropic is rather verbose, so we clean it up a bit, using a lowercase version of the name.\n\nusage(5)\n\nUsage(input_tokens=5, output_tokens=0)\n\n\n\nsource\n\n\nUsage.total\n\n Usage.total ()\n\n\n\nExported source\n@patch(as_prop=True)\ndef total(self:Usage): return self.input_tokens+self.output_tokens\n\n\nAdding a total property to Usage makes it easier to see how many tokens we’ve used up altogether.\n\nusage(5,1).total\n\n6\n\n\n\nsource\n\n\nUsage.__repr__\n\n Usage.__repr__ ()\n\nReturn repr(self).\n\n\nExported source\n@patch\ndef __repr__(self:Usage): return f'In: {self.input_tokens}; Out: {self.output_tokens}; Total: {self.total}'\n\n\nIn python, patching __repr__ lets us change how an object is displayed. (More generally, methods starting and ending in __ in Python are called dunder methods, and have some magic behavior – such as, in this case, changing how an object is displayed.)\n\nr.usage\n\nIn: 10; Out: 23; Total: 33\n\n\n\nsource\n\n\nUsage.__add__\n\n Usage.__add__ (b)\n\nAdd together each of input_tokens and output_tokens\n\n\nExported source\n@patch\ndef __add__(self:Usage, b):\n    \"Add together each of `input_tokens` and `output_tokens`\"\n    return usage(self.input_tokens+b.input_tokens, self.output_tokens+b.output_tokens)\n\n\nAnd, patching __add__ lets + work on a Usage object.\n\nr.usage+r.usage\n\nIn: 20; Out: 46; Total: 66\n\n\n\n\nCreating messages\nCreating correctly formatted dicts from scratch every time isn’t very handy, so next up we’ll add helpers for this.\n\ndef mk_msg(content, role='user', **kw):\n    return dict(role=role, content=content, **kw)\n\nWe make things a bit more convenient by writing a function to create a message for us.\n\n\n\n\n\n\nNote\n\n\n\nYou may have noticed that we didn’t export the mk_msg function (i.e. there’s no “Exported source” block around it). That’s because we’ll need more functionality in our final version than this version has – so we’ll be defining a more complete version later. Rather than refactoring/editing in notebooks, often it’s helpful to simply gradually build up complexity by re-defining a symbol.\n\n\n\nprompt = \"I'm Jeremy\"\nm = mk_msg(prompt)\nm\n\n{'role': 'user', 'content': \"I'm Jeremy\"}\n\n\n\nr = cli.messages.create(messages=[m], model=model, max_tokens=100)\nr\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_017RAP4TephYyTFyKyfhsUxk\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 36}\n\n\n\n\n\nsource\n\n\nmk_msgs\n\n mk_msgs (msgs:list, **kw)\n\nHelper to set ‘assistant’ role on alternate messages.\n\n\nExported source\ndef mk_msgs(msgs:list, **kw):\n    \"Helper to set 'assistant' role on alternate messages.\"\n    if isinstance(msgs,str): msgs=[msgs]\n    return [mk_msg(o, ('user','assistant')[i%2], **kw) for i,o in enumerate(msgs)]\n\n\nLLMs, including Claude, don’t actually have state, but instead dialogs are created by passing back all previous prompts and responses every time. With Claude, they always alternate user and assistant. Therefore we create a function to make it easier to build up these dialog lists.\nBut to do so, we need to update mk_msg so that we can’t only pass a str as content, but can also pass a dict or an object with a content attr, since these are both types of message that Claude can create. To do so, we check for a content key or attr, and use it if found.\n\ndef mk_msg(content, role='user', **kw):\n    \"Helper to create a `dict` appropriate for a Claude message. `kw` are added as key/value pairs to the message\"\n    if hasattr(content, 'content'): content,role = content.content,content.role\n    if isinstance(content, abc.Mapping): content=content['content']\n    return dict(role=role, content=content, **kw)\n\n\nmsgs = mk_msgs([prompt, r, 'I forgot my name. Can you remind me please?'])\nmsgs\n\n[{'role': 'user', 'content': \"I'm Jeremy\"},\n {'role': 'assistant',\n  'content': [TextBlock(text=\"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", type='text')]},\n {'role': 'user', 'content': 'I forgot my name. Can you remind me please?'}]\n\n\nNow, if we pass this list of messages to Claude, the model treats it as a conversation to respond to.\n\ncli.messages.create(messages=msgs, model=model, max_tokens=200)\n\nOf course! You just told me that your name is Jeremy.\n\n\nid: msg_01YWeAebsvvgLXSfy1HgZbNK\ncontent: [{'text': 'Of course! You just told me that your name is Jeremy.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 60, 'output_tokens': 16}",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#client",
    "href": "core.html#client",
    "title": "Claudette’s source",
    "section": "Client",
    "text": "Client\n\nsource\n\nClient\n\n Client (model, cli=None, log=False)\n\nBasic Anthropic messages client.\n\n\nExported source\nclass Client:\n    def __init__(self, model, cli=None, log=False):\n        \"Basic Anthropic messages client.\"\n        self.model,self.use = model,usage()\n        self.log = [] if log else None\n        self.c = (cli or Anthropic(default_headers={'anthropic-beta': 'prompt-caching-2024-07-31'}))\n\n\nWe’ll create a simple Client for Anthropic which tracks usage stores the model to use. We don’t add any methods right away – instead we’ll use patch for that so we can add and document them incrementally.\n\nc = Client(model)\nc.use\n\nIn: 0; Out: 0; Total: 0\n\n\n\n\nExported source\n@patch\ndef _r(self:Client, r:Message, prefill=''):\n    \"Store the result of the message and accrue total usage.\"\n    if prefill:\n        blk = find_block(r)\n        blk.text = prefill + (blk.text or '')\n    self.result = r\n    self.use += r.usage\n    self.stop_reason = r.stop_reason\n    self.stop_sequence = r.stop_sequence\n    return r\n\n\nWe use a _ prefix on private methods, but we document them here in the interests of literate source code.\n_r will be used each time we get a new result, to track usage and also to keep the result available for later.\n\nc._r(r)\nc.use\n\nIn: 10; Out: 36; Total: 46\n\n\nWhereas OpenAI’s models use a stream parameter for streaming, Anthropic’s use a separate method. We implement Anthropic’s approach in a private method, and then use a stream parameter in __call__ for consistency:\n\n\nExported source\n@patch\ndef _log(self:Client, final, prefill, msgs, maxtok=None, sp=None, temp=None, stream=None, stop=None, **kwargs):\n    self._r(final, prefill)\n    if self.log is not None: self.log.append({\n        \"msgs\": msgs, \"prefill\": prefill, **kwargs,\n        \"msgs\": msgs, \"prefill\": prefill, \"maxtok\": maxtok, \"sp\": sp, \"temp\": temp, \"stream\": stream, \"stop\": stop, **kwargs,\n        \"result\": self.result, \"use\": self.use, \"stop_reason\": self.stop_reason, \"stop_sequence\": self.stop_sequence\n    })\n    return self.result\n\n\n\n\nExported source\n@patch\ndef _stream(self:Client, msgs:list, prefill='', **kwargs):\n    with self.c.messages.stream(model=self.model, messages=mk_msgs(msgs), **kwargs) as s:\n        if prefill: yield(prefill)\n        yield from s.text_stream\n        self._log(s.get_final_message(), prefill, msgs, **kwargs)\n\n\nClaude supports adding an extra assistant message at the end, which contains the prefill – i.e. the text we want Claude to assume the response starts with. However Claude doesn’t actually repeat that in the response, so for convenience we add it.\n\nsource\n\n\nClient.__call__\n\n Client.__call__ (msgs:list, sp='', temp=0, maxtok=4096, prefill='',\n                  stream:bool=False, stop=None, metadata:message_create_pa\n                  rams.Metadata|NotGiven=NOT_GIVEN,\n                  stop_sequences:List[str]|NotGiven=NOT_GIVEN, system:Unio\n                  n[str,Iterable[TextBlockParam]]|NotGiven=NOT_GIVEN,\n                  temperature:float|NotGiven=NOT_GIVEN, tool_choice:messag\n                  e_create_params.ToolChoice|NotGiven=NOT_GIVEN,\n                  tools:Iterable[ToolParam]|NotGiven=NOT_GIVEN,\n                  top_k:int|NotGiven=NOT_GIVEN,\n                  top_p:float|NotGiven=NOT_GIVEN,\n                  extra_headers:Headers|None=None,\n                  extra_query:Query|None=None, extra_body:Body|None=None,\n                  timeout:float|httpx.Timeout|None|NotGiven=NOT_GIVEN)\n\nMake a call to Claude.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmsgs\nlist\n\nList of messages in the dialog\n\n\nsp\nstr\n\nThe system prompt\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nstream\nbool\nFalse\nStream response?\n\n\nstop\nNoneType\nNone\nStop sequence\n\n\nmetadata\nmessage_create_params.Metadata | NotGiven\nNOT_GIVEN\n\n\n\nstop_sequences\nList[str] | NotGiven\nNOT_GIVEN\n\n\n\nsystem\nUnion[str, Iterable[TextBlockParam]] | NotGiven\nNOT_GIVEN\n\n\n\ntemperature\nfloat | NotGiven\nNOT_GIVEN\n\n\n\ntool_choice\nmessage_create_params.ToolChoice | NotGiven\nNOT_GIVEN\n\n\n\ntools\nIterable[ToolParam] | NotGiven\nNOT_GIVEN\n\n\n\ntop_k\nint | NotGiven\nNOT_GIVEN\n\n\n\ntop_p\nfloat | NotGiven\nNOT_GIVEN\n\n\n\nextra_headers\nHeaders | None\nNone\n\n\n\nextra_query\nQuery | None\nNone\n\n\n\nextra_body\nBody | None\nNone\n\n\n\ntimeout\nfloat | httpx.Timeout | None | NotGiven\nNOT_GIVEN\n\n\n\n\n\n\nExported source\n@patch\ndef _precall(self:Client, msgs, prefill, stop, kwargs):\n    pref = [prefill.strip()] if prefill else []\n    if not isinstance(msgs,list): msgs = [msgs]\n    if stop is not None:\n        if not isinstance(stop, (list)): stop = [stop]\n        kwargs[\"stop_sequences\"] = stop\n    msgs = mk_msgs(msgs+pref)\n    return msgs\n\n\n\n\nExported source\n@patch\n@delegates(messages.Messages.create)\ndef __call__(self:Client,\n             msgs:list, # List of messages in the dialog\n             sp='', # The system prompt\n             temp=0, # Temperature\n             maxtok=4096, # Maximum tokens\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             stream:bool=False, # Stream response?\n             stop=None, # Stop sequence\n             **kwargs):\n    \"Make a call to Claude.\"\n    msgs = self._precall(msgs, prefill, stop, kwargs)\n    if stream: return self._stream(msgs, prefill=prefill, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    res = self.c.messages.create(\n        model=self.model, messages=msgs, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    return self._log(res, prefill, msgs, maxtok, sp, temp, stream=stream, stop=stop, **kwargs)\n\n\nDefining __call__ let’s us use an object like a function (i.e it’s callable). We use it as a small wrapper over messages.create.\n\nc = Client(model, log=True)\nc.use\n\nIn: 0; Out: 0; Total: 0\n\n\n\nc.model = models[-1]\n\n\nc('Hi')\n\nHello! How can I assist you today?\n\n\nid: msg_01ADNqsrkyiEoMpqQy8WY8DC\ncontent: [{'text': 'Hello! How can I assist you today?', 'type': 'text'}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 8, 'output_tokens': 12, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nc.use\n\nIn: 8; Out: 12; Total: 20\n\n\nLet’s try out prefill:\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\n\n\nc(q, prefill=pref)\n\nAccording to Douglas Adams, “The answer to the ultimate question of life, the universe, and everything is 42.”\n\n\nid: msg_01RxVtMH3djiS3pRc8Do2SFA\ncontent: [{'text': 'According to Douglas Adams,  \"The answer to the ultimate question of life, the universe, and everything is 42.\"', 'type': 'text'}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 24, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nWe can pass stream=True to stream the response back incrementally:\n\nfor o in c('Hi', stream=True): print(o, end='')\n\nHello! How can I assist you today?\n\n\n\nc.use\n\nIn: 40; Out: 47; Total: 87\n\n\n\nfor o in c(q, prefill=pref, stream=True): print(o, end='')\n\nAccording to Douglas Adams,  \"The answer to the ultimate question of life, the universe, and everything is 42.\"\n\n\n\nc.use\n\nIn: 64; Out: 70; Total: 134\n\n\nPass a stop seauence if you want claude to stop generating text when it encounters it.\n\nc(\"Count from 1 to 10\", stop=\"5\")\n\n1, 2, 3, 4,\n\n\nid: msg_013P6ntb5vP2XGwUdDrAcxSP\ncontent: [{'text': '1, 2, 3, 4, ', 'type': 'text'}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: stop_sequence\nstop_sequence: 5\ntype: message\nusage: {'input_tokens': 15, 'output_tokens': 14, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nThis also works with streaming, and you can pass more than one stop sequence:\n\nfor o in c(\"Count from 1 to 10\", stop=[\"2\", \"yellow\"], stream=True):\n    print(o, end='')\nprint(c.stop_reason, c.stop_sequence)\n\n1, stop_sequence 2\n\n\nYou can check the logs:\n\nc.log[-1]\n\n{'msgs': [{'role': 'user', 'content': 'Count from 1 to 10'}],\n 'prefill': '',\n 'max_tokens': 4096,\n 'system': '',\n 'temperature': 0,\n 'stop_sequences': ['2', 'yellow'],\n 'maxtok': None,\n 'sp': None,\n 'temp': None,\n 'stream': None,\n 'stop': None,\n 'result': Message(id='msg_01Mcd8Mxnw3zMwtUy1y5Q1gf', content=[TextBlock(text='1, ', type='text')], model='claude-3-haiku-20240307', role='assistant', stop_reason='stop_sequence', stop_sequence='2', type='message', usage=In: 15; Out: 5; Total: 20),\n 'use': In: 94; Out: 89; Total: 183,\n 'stop_reason': 'stop_sequence',\n 'stop_sequence': '2'}",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#tool-use",
    "href": "core.html#tool-use",
    "title": "Claudette’s source",
    "section": "Tool use",
    "text": "Tool use\nLet’s now add tool use (aka function calling).\n\nsource\n\nmk_tool_choice\n\n mk_tool_choice (choose:Union[str,bool,NoneType])\n\nCreate a tool_choice dict that’s ‘auto’ if choose is None, ‘any’ if it is True, or ‘tool’ otherwise\n\n\nExported source\ndef mk_tool_choice(choose:Union[str,bool,None])-&gt;dict:\n    \"Create a `tool_choice` dict that's 'auto' if `choose` is `None`, 'any' if it is True, or 'tool' otherwise\"\n    return {\"type\": \"tool\", \"name\": choose} if isinstance(choose,str) else {'type':'any'} if choose else {'type':'auto'}\n\n\n\nprint(mk_tool_choice('sums'))\nprint(mk_tool_choice(True))\nprint(mk_tool_choice(None))\n\n{'type': 'tool', 'name': 'sums'}\n{'type': 'any'}\n{'type': 'auto'}\n\n\nClaude can be forced to use a particular tool, or select from a specific list of tools, or decide for itself when to use a tool. If you want to force a tool (or force choosing from a list), include a tool_choice param with a dict from mk_tool_choice.\nFor testing, we need a function that Claude can call; we’ll write a simple function that adds numbers together, and will tell us when it’s being called:\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\n\na,b = 604542,6458932\npr = f\"What is {a}+{b}?\"\nsp = \"You are a summing expert.\"\n\nClaudette can autogenerate a schema thanks to the toolslm library. We’ll force the use of the tool using the function we created earlier.\n\ntools=[get_schema(sums)]\nchoice = mk_tool_choice('sums')\n\nWe’ll start a dialog with Claude now. We’ll store the messages of our dialog in msgs. The first message will be our prompt pr, and we’ll pass our tools schema.\n\nmsgs = mk_msgs(pr)\nr = c(msgs, sp=sp, tools=tools, tool_choice=choice)\nr\n\nToolUseBlock(id=‘toolu_01KZ2VpnTQmG26UzfAotM98g’, input={‘a’: 604542, ‘b’: 6458932}, name=‘sums’, type=‘tool_use’)\n\n\nid: msg_013KmnCBTXC1kJmefF9LfF3d\ncontent: [{'id': 'toolu_01KZ2VpnTQmG26UzfAotM98g', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 493, 'output_tokens': 53, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nWhen Claude decides that it should use a tool, it passes back a ToolUseBlock with the name of the tool to call, and the params to use.\nWe don’t want to allow it to call just any possible function (that would be a security disaster!) so we create a namespace – that is, a dictionary of allowable function names to call.\n\n\nExported source\ndef _mk_ns(*funcs:list[callable]) -&gt; dict[str,callable]:\n    \"Create a `dict` of name to function in `funcs`, to use as a namespace\"\n    return {f.__name__:f for f in funcs}\n\n\n\nns = _mk_ns(sums)\nns\n\n{'sums': &lt;function __main__.sums(a: int, b: int = 1) -&gt; int&gt;}\n\n\n\nsource\n\n\nmk_funcres\n\n mk_funcres (tuid, res)\n\nGiven tool use id and the tool result, create a tool_result response.\n\n\nExported source\ndef call_func(fc:ToolUseBlock, # Tool use block from Claude's message\n              ns:Optional[abc.Mapping]=None, # Namespace to search for tools, defaults to `globals()`\n              obj:Optional=None # Object to search for tools\n             ):\n    \"Call the function in the tool response `tr`, using namespace `ns`.\"\n    if ns is None: ns=globals()\n    if not isinstance(ns, abc.Mapping): ns = _mk_ns(*ns)\n    func = getattr(obj, fc.name, None)\n    if not func: func = ns[fc.name]\n    res = func(**fc.input)\n    return res\n\ndef mk_funcres(tuid, res):\n    \"Given tool use id and the tool result, create a tool_result response.\"\n    return dict(type=\"tool_result\", tool_use_id=tuid, content=str(res))\n\n\n\nsource\n\n\ncall_func\n\n call_func (fc:anthropic.types.tool_use_block.ToolUseBlock,\n            ns:Optional[collections.abc.Mapping]=None, obj:Optional=None)\n\nCall the function in the tool response tr, using namespace ns.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfc\nToolUseBlock\n\nTool use block from Claude’s message\n\n\nns\nOptional\nNone\nNamespace to search for tools, defaults to globals()\n\n\nobj\nOptional\nNone\nObject to search for tools\n\n\n\nWe can now use the function requested by Claude. We look it up in ns, and pass in the provided parameters.\n\nfc = find_block(r, ToolUseBlock)\nres = mk_funcres(fc.id, call_func(fc, ns=ns))\nres\n\nFinding the sum of 604542 and 6458932\n\n\n{'type': 'tool_result',\n 'tool_use_id': 'toolu_01KZ2VpnTQmG26UzfAotM98g',\n 'content': '7063474'}\n\n\n\nsource\n\n\nmk_toolres\n\n mk_toolres (r:collections.abc.Mapping,\n             ns:Optional[collections.abc.Mapping]=None, obj:Optional=None)\n\nCreate a tool_result message from response r.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nr\nMapping\n\nTool use request response from Claude\n\n\nns\nOptional\nNone\nNamespace to search for tools\n\n\nobj\nOptional\nNone\nClass to search for tools\n\n\n\n\n\nExported source\ndef mk_toolres(\n    r:abc.Mapping, # Tool use request response from Claude\n    ns:Optional[abc.Mapping]=None, # Namespace to search for tools\n    obj:Optional=None # Class to search for tools\n    ):\n    \"Create a `tool_result` message from response `r`.\"\n    cts = getattr(r, 'content', [])\n    res = [mk_msg(r)]\n    tcs = [mk_funcres(o.id, call_func(o, ns=ns, obj=obj)) for o in cts if isinstance(o,ToolUseBlock)]\n    if tcs: res.append(mk_msg(tcs))\n    return res\n\n\nIn order to tell Claude the result of the tool call, we pass back the tool use assistant request and the tool_result response.\n\ntr = mk_toolres(r, ns=ns)\ntr\n\nFinding the sum of 604542 and 6458932\n\n\n[{'role': 'assistant',\n  'content': [ToolUseBlock(id='toolu_01KZ2VpnTQmG26UzfAotM98g', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')]},\n {'role': 'user',\n  'content': [{'type': 'tool_result',\n    'tool_use_id': 'toolu_01KZ2VpnTQmG26UzfAotM98g',\n    'content': '7063474'}]}]\n\n\nWe add this to our dialog, and now Claude has all the information it needs to answer our question.\n\nmsgs += tr\ncontents(c(msgs, sp=sp, tools=tools))\n\n'The sum of 604542 and 6458932 is 7063474.'\n\n\nThis works with methods as well – in this case, use the object itself for ns:\n\nclass Dummy:\n    def sums(\n        self,\n        a:int,  # First thing to sum\n        b:int=1 # Second thing to sum\n    ) -&gt; int: # The sum of the inputs\n        \"Adds a + b.\"\n        print(f\"Finding the sum of {a} and {b}\")\n        return a + b\n\n\ntools = [get_schema(Dummy.sums)]\no = Dummy()\n\nmsgs = mk_msgs(pr)\nr = c(msgs, sp=sp, tools=tools, tool_choice=choice)\ntr = mk_toolres(r, obj=o)\nmsgs += tr\ncontents(c(msgs, sp=sp, tools=tools))\n\nFinding the sum of 604542 and 6458932\n\n\n'The sum of 604542 and 6458932 is 7063474.'",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#chat",
    "href": "core.html#chat",
    "title": "Claudette’s source",
    "section": "Chat",
    "text": "Chat\nRather than manually adding the responses to a dialog, we’ll create a simple Chat class to do that for us, each time we make a request. We’ll also store the system prompt and tools here, to avoid passing them every time.\n\nsource\n\nChat\n\n Chat (model:Optional[str]=None, cli:Optional[__main__.Client]=None,\n       sp='', tools:Optional[list]=None, cont_pr:Optional[str]=None,\n       tool_choice:Optional[dict]=None)\n\nAnthropic chat client.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmodel\nOptional\nNone\nModel to use (leave empty if passing cli)\n\n\ncli\nOptional\nNone\nClient to use (leave empty if passing model)\n\n\nsp\nstr\n\nOptional system prompt\n\n\ntools\nOptional\nNone\nList of tools to make available to Claude\n\n\ncont_pr\nOptional\nNone\nUser prompt to continue an assistant response: assistant,[user:“…”],assistant\n\n\ntool_choice\nOptional\nNone\nOptionally force use of some tool\n\n\n\n\n\nExported source\nclass Chat:\n    def __init__(self,\n                 model:Optional[str]=None, # Model to use (leave empty if passing `cli`)\n                 cli:Optional[Client]=None, # Client to use (leave empty if passing `model`)\n                 sp='', # Optional system prompt\n                 tools:Optional[list]=None, # List of tools to make available to Claude\n                 cont_pr:Optional[str]=None, # User prompt to continue an assistant response: assistant,[user:\"...\"],assistant\n                 tool_choice:Optional[dict]=None): # Optionally force use of some tool\n        \"Anthropic chat client.\"\n        assert model or cli\n        assert cont_pr != \"\", \"cont_pr may not be an empty string\"\n        self.c = (cli or Client(model))\n        self.h,self.sp,self.tools,self.cont_pr,self.tool_choice = [],sp,tools,cont_pr,tool_choice\n\n    @property\n    def use(self): return self.c.use\n\n\nThe class stores the Client that will provide the responses in c, and a history of messages in h.\n\nsp = \"Never mention what tools you use.\"\nchat = Chat(model, sp=sp)\nchat.c.use, chat.h\n\n(In: 0; Out: 0; Total: 0, [])\n\n\n\nsource\n\n\nChat.__call__\n\n Chat.__call__ (pr=None, temp=0, maxtok=4096, stream=False, prefill='',\n                **kw)\n\nCall self as a function.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npr\nNoneType\nNone\nPrompt / message\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nstream\nbool\nFalse\nStream response?\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nkw\n\n\n\n\n\n\n\n\nExported source\n@patch\ndef _stream(self:Chat, res):\n    yield from res\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n\n\n\n\nExported source\n@patch\ndef _post_pr(self:Chat, pr, prev_role):\n    if pr is None and prev_role == 'assistant':\n        if self.cont_pr is None:\n            raise ValueError(\"Prompt must be given after assistant completion, or use `self.cont_pr`.\")\n        pr = self.cont_pr # No user prompt, keep the chain\n    if pr: self.h.append(mk_msg(pr))\n\n\n\n\nExported source\n@patch\ndef _append_pr(self:Chat,\n               pr=None,  # Prompt / message\n              ):\n    prev_role = nested_idx(self.h, -1, 'role') if self.h else 'assistant' # First message should be 'user'\n    if pr and prev_role == 'user': self() # already user request pending\n    self._post_pr(pr, prev_role)\n\n\n\n\nExported source\n@patch\ndef __call__(self:Chat,\n             pr=None,  # Prompt / message\n             temp=0, # Temperature\n             maxtok=4096, # Maximum tokens\n             stream=False, # Stream response?\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             **kw):\n    self._append_pr(pr)\n    if self.tools: kw['tools'] = [get_schema(o) for o in self.tools]\n    if self.tool_choice and pr: kw['tool_choice'] = mk_tool_choice(self.tool_choice)\n    res = self.c(self.h, stream=stream, prefill=prefill, sp=self.sp, temp=temp, maxtok=maxtok, **kw)\n    if stream: return self._stream(res)\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n    return res\n\n\nThe __call__ method just passes the request along to the Client, but rather than just passing in this one prompt, it appends it to the history and passes it all along. As a result, we now have state!\n\nchat(\"I'm Jeremy\")\nchat(\"What's my name?\")\n\nYour name is Jeremy.\n\n\nid: msg_01DJHYAMYuC7TQSdMCmeQiaq\ncontent: [{'text': 'Your name is Jeremy.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 235, 'output_tokens': 8, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nLet’s try out prefill too:\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\n\n\nchat(q, prefill=pref)\n\nAccording to Douglas Adams, the meaning of life is 42. More seriously, there’s no universally agreed upon answer. Common philosophical perspectives include:\n\nFinding personal fulfillment\nServing others\nPursuing happiness\nCreating meaning through our choices\nExperiencing and appreciating existence\n\nUltimately, many believe each individual must determine their own life’s meaning.\n\n\nid: msg_01PLpsyGYqjVTMnvtGqzh1qD\ncontent: [{'text': \"According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common philosophical perspectives include:\\n\\n1. Finding personal fulfillment\\n2. Serving others\\n3. Pursuing happiness\\n4. Creating meaning through our choices\\n5. Experiencing and appreciating existence\\n\\nUltimately, many believe each individual must determine their own life's meaning.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 263, 'output_tokens': 82, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nBy default messages must be in user, assistant, user format. If this isn’t followed (aka calling chat() without a user message) it will error out:\n\ntry: chat()\nexcept ValueError as e: print(\"Error:\", e)\n\nError: Prompt must be given after assistant completion, or use `self.cont_pr`.\n\n\nSetting cont_pr allows a “default prompt” to be specified when a prompt isn’t specified. Usually used to prompt the model to continue.\n\nchat.cont_pr = \"keep going...\"\nchat()\n\nContinuing on the topic of the meaning of life:\n\nAchieving self-actualization\nLeaving a positive legacy\nConnecting with others and forming relationships\nPursuing knowledge and understanding\nEmbracing spiritual or religious beliefs\nOvercoming challenges and growing as a person\nContributing to the advancement of humanity\nFinding balance and harmony in life\nExpressing creativity and individuality\nExperiencing love in its various forms\n\nThese perspectives often overlap and can be combined in various ways. The search for meaning itself is considered by some to be an essential part of the human experience.\n\n\nid: msg_0195oiRnvGTs64CCiQrESVn4\ncontent: [{'text': 'Continuing on the topic of the meaning of life:\\n\\n6. Achieving self-actualization\\n7. Leaving a positive legacy\\n8. Connecting with others and forming relationships\\n9. Pursuing knowledge and understanding\\n10. Embracing spiritual or religious beliefs\\n11. Overcoming challenges and growing as a person\\n12. Contributing to the advancement of humanity\\n13. Finding balance and harmony in life\\n14. Expressing creativity and individuality\\n15. Experiencing love in its various forms\\n\\nThese perspectives often overlap and can be combined in various ways. The search for meaning itself is considered by some to be an essential part of the human experience.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 351, 'output_tokens': 139, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nYou can see that the continue prompt is injected to keep the user,assistant going.\n\nchat.h[-3:]\n\n[{'role': 'assistant',\n  'content': [TextBlock(text=\"According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common philosophical perspectives include:\\n\\n1. Finding personal fulfillment\\n2. Serving others\\n3. Pursuing happiness\\n4. Creating meaning through our choices\\n5. Experiencing and appreciating existence\\n\\nUltimately, many believe each individual must determine their own life's meaning.\", type='text')]},\n {'role': 'user', 'content': 'keep going...'},\n {'role': 'assistant',\n  'content': [TextBlock(text='Continuing on the topic of the meaning of life:\\n\\n6. Achieving self-actualization\\n7. Leaving a positive legacy\\n8. Connecting with others and forming relationships\\n9. Pursuing knowledge and understanding\\n10. Embracing spiritual or religious beliefs\\n11. Overcoming challenges and growing as a person\\n12. Contributing to the advancement of humanity\\n13. Finding balance and harmony in life\\n14. Expressing creativity and individuality\\n15. Experiencing love in its various forms\\n\\nThese perspectives often overlap and can be combined in various ways. The search for meaning itself is considered by some to be an essential part of the human experience.', type='text')]}]\n\n\nWe can also use streaming:\n\nchat = Chat(model, sp=sp)\nfor o in chat(\"I'm Jeremy\", stream=True): print(o, end='')\n\nHello Jeremy! It's nice to meet you. How are you doing today? Is there anything in particular you'd like to chat about or any questions I can help you with?\n\n\n\nfor o in chat(q, prefill=pref, stream=True): print(o, end='')\n\nAccording to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common perspectives include:\n\n1. Finding personal fulfillment\n2. Serving others\n3. Pursuing knowledge\n4. Experiencing love and relationships\n5. Creating or appreciating art\n6. Achieving goals\n7. Living according to religious or spiritual beliefs\n\nUltimately, many philosophers argue that each individual must determine their own meaning.\n\n\n\n\nChat tool use\nWe automagically get streamlined tool use as well:\n\npr = f\"What is {a}+{b}?\"\npr\n\n'What is 604542+6458932?'\n\n\n\nchat = Chat(model, sp=sp, tools=[sums])\nr = chat(pr)\nr\n\nFinding the sum of 604542 and 6458932\n\n\nTo answer this question, I can use the “sums” function to add these two numbers together. Let me do that for you.\n\n\nid: msg_01S2onXQ4zAtGJ4ZWzBf2Nba\ncontent: [{'text': 'To answer this question, I can use the \"sums\" function to add these two numbers together. Let me do that for you.', 'type': 'text'}, {'id': 'toolu_01PTAt1do4WtDkhszUupaoRK', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 428, 'output_tokens': 101, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nchat()\n\nThe sum of 604542 and 6458932 is 7063474.\n\n\nid: msg_01KYftq2WktJjfJJ6ikymqDQ\ncontent: [{'text': 'The sum of 604542 and 6458932 is 7063474.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 543, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nIt should be correct, because it actually used our Python function to do the addition. Let’s check:\n\na+b\n\n7063474",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#images",
    "href": "core.html#images",
    "title": "Claudette’s source",
    "section": "Images",
    "text": "Images\nClaude can handle image data as well. As everyone knows, when testing image APIs you have to use a cute puppy.\n\n# Image is Cute_dog.jpg from Wikimedia\nfn = Path('samples/puppy.jpg')\ndisplay.Image(filename=fn, width=200)\n\n\n\n\n\n\n\n\n\nimg = fn.read_bytes()\n\n\n\nExported source\ndef _add_cache(d, cache):\n    \"Optionally add cache control\"\n    if cache: d[\"cache_control\"] = {\"type\": \"ephemeral\"}\n    return d\n\n\nClaude supports context caching by adding a cache_control header, so we provide an option to enable that.\n\nsource\n\nimg_msg\n\n img_msg (data:bytes, cache=False)\n\nConvert image data into an encoded dict\n\n\nExported source\ndef img_msg(data:bytes, cache=False)-&gt;dict:\n    \"Convert image `data` into an encoded `dict`\"\n    img = base64.b64encode(data).decode(\"utf-8\")\n    mtype = mimetypes.types_map['.'+imghdr.what(None, h=data)]\n    r = dict(type=\"base64\", media_type=mtype, data=img)\n    return _add_cache({\"type\": \"image\", \"source\": r}, cache)\n\n\nAnthropic have documented the particular dict structure that expect image data to be in, so we have a little function to create that for us.\n\nsource\n\n\ntext_msg\n\n text_msg (s:str, cache=False)\n\nConvert s to a text message\n\n\nExported source\ndef text_msg(s:str, cache=False)-&gt;dict:\n    \"Convert `s` to a text message\"\n    return _add_cache({\"type\": \"text\", \"text\": s}, cache)\n\n\nA Claude message can be a list of image and text parts. So we’ve also created a helper for making the text parts.\n\nq = \"In brief, what color flowers are in this image?\"\nmsg = mk_msg([img_msg(img), text_msg(q)])\n\n\nc([msg])\n\nThe image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.\n\n\nid: msg_01J7xj3C8LreZL78x6jghP9u\ncontent: [{'text': 'The image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.', 'type': 'text'}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 110, 'output_tokens': 28, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\n\nExported source\ndef _mk_content(src, cache=False):\n    \"Create appropriate content data structure based on type of content\"\n    if isinstance(src,str): return text_msg(src, cache=cache)\n    if isinstance(src,bytes): return img_msg(src, cache=cache)\n    return src\n\n\nThere’s not need to manually choose the type of message, since we figure that out from the data of the source data.\n\n_mk_content('Hi')\n\n{'type': 'text', 'text': 'Hi'}\n\n\n\nsource\n\n\nmk_msg\n\n mk_msg (content, role='user', cache=False, **kw)\n\nHelper to create a dict appropriate for a Claude message. kw are added as key/value pairs to the message\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncontent\n\n\nA string, list, or dict containing the contents of the message\n\n\nrole\nstr\nuser\nMust be ‘user’ or ‘assistant’\n\n\ncache\nbool\nFalse\n\n\n\nkw\n\n\n\n\n\n\n\n\nExported source\ndef mk_msg(content, # A string, list, or dict containing the contents of the message\n           role='user', # Must be 'user' or 'assistant'\n           cache=False,\n           **kw):\n    \"Helper to create a `dict` appropriate for a Claude message. `kw` are added as key/value pairs to the message\"\n    if hasattr(content, 'content'): content,role = content.content,content.role\n    if isinstance(content, abc.Mapping): content=content.get('content', content)\n    if not isinstance(content, list): content=[content]\n    content = [_mk_content(o, cache if islast else False) for islast,o in loop_last(content)] if content else '.'\n    return dict(role=role, content=content, **kw)\n\n\n\nmk_msg(['hi', 'there'], cache=True)\n\n{'role': 'user',\n 'content': [{'type': 'text', 'text': 'hi'},\n  {'type': 'text', 'text': 'there', 'cache_control': {'type': 'ephemeral'}}]}\n\n\nWhen we construct a message, we now use _mk_content to create the appropriate parts. Since a dialog contains multiple messages, and a message can contain multiple content parts, to pass a single message with multiple parts we have to use a list containing a single list:\n\nc([[img, q]])\n\nThe image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.\n\n\nid: msg_01DMPFL3DPjKLoarGA2wjni7\ncontent: [{'text': 'The image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.', 'type': 'text'}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 110, 'output_tokens': 28, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAs promised (much!) earlier, we’ve now finally completed our definition of mk_msg, and this version is the one we export to the Python module.",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#third-party-providers",
    "href": "core.html#third-party-providers",
    "title": "Claudette’s source",
    "section": "Third party providers",
    "text": "Third party providers\n\nAmazon Bedrock\nThese are Amazon’s current Claude models:\nWe don’t need any extra code to support Amazon Bedrock – we just have to set up the approach client:\n\nab = AnthropicBedrock(\n    aws_access_key=os.environ['AWS_ACCESS_KEY'],\n    aws_secret_key=os.environ['AWS_SECRET_KEY'],\n)\nclient = Client(models_aws[-1], ab)\n\n\nchat = Chat(cli=client)\n\n\nchat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_bdrk_01MwjVA5hwyfob3w4vdsqpnU\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 36}\n\n\n\n\n\n\nGoogle Vertex\n\nfrom anthropic import AnthropicVertex\nimport google.auth\n\n\nproject_id = google.auth.default()[1]\nregion = \"us-east5\"\ngv = AnthropicVertex(project_id=project_id, region=region)\nclient = Client(models_goog[-1], gv)\n\n\nchat = Chat(cli=client)\n\n\nchat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_vrtx_01PFtHewPDe35yShy7vecp5q\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 36}",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "CHANGELOG.html#section",
    "href": "CHANGELOG.html#section",
    "title": "",
    "section": "0.0.9",
    "text": "0.0.9\n\nNew Features\n\nAsync support (#21)"
  },
  {
    "objectID": "CHANGELOG.html#section-1",
    "href": "CHANGELOG.html#section-1",
    "title": "",
    "section": "0.0.7",
    "text": "0.0.7\n\nNew Features\n\nPrompt caching (#20)\nadd markdown to doc output (#19)\nSupport vscode details tags (#18)\nAdd a cont_pr param to Chat as a “default” prompt #15), thanks to @tom-pollak\n\n\n\nBugs Squashed\n\nExplicit tool_choice causes chat() to call tool twice. (#11)"
  },
  {
    "objectID": "CHANGELOG.html#section-2",
    "href": "CHANGELOG.html#section-2",
    "title": "",
    "section": "0.0.6",
    "text": "0.0.6\n\nNew Features\n\nDefault chat prompt & function calling refactor (#15), thanks to @tom-pollak"
  },
  {
    "objectID": "CHANGELOG.html#section-3",
    "href": "CHANGELOG.html#section-3",
    "title": "",
    "section": "0.0.5",
    "text": "0.0.5\n\nNew Features\n\nBetter support for stop sequences (#12), thanks to @xl0"
  },
  {
    "objectID": "CHANGELOG.html#section-4",
    "href": "CHANGELOG.html#section-4",
    "title": "",
    "section": "0.0.3",
    "text": "0.0.3\n\nNew Features\n\nAmazon Bedrock and Google Vertex support (#7)\n\n\n\nBug Fixes\n\nUpdate model paths for non-beta tool use (#2), thanks to @sarahpannn"
  },
  {
    "objectID": "CHANGELOG.html#section-5",
    "href": "CHANGELOG.html#section-5",
    "title": "",
    "section": "0.0.1",
    "text": "0.0.1\n\nInitial release"
  }
]