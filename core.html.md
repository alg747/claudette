# Claudette’s source


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

This is the ‘literate’ source code for Claudette. You can view the fully
rendered version of the notebook
[here](https://claudette.answer.ai/core.html), or you can clone the git
repo and run the [interactive
notebook](https://github.com/AnswerDotAI/claudette/blob/main/00_core.ipynb)
in Jupyter. The notebook is converted the [Python module
claudette/core.py](https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py)
using [nbdev](https://nbdev.fast.ai/). The goal of this source code is
to both create the Python module, and also to teach the reader *how* it
is created, without assuming much existing knowledge about Claude’s API.

Most of the time you’ll see that we write some source code *first*, and
then a description or discussion of it *afterwards*.

## Setup

``` python
import os
# os.environ['ANTHROPIC_LOG'] = 'debug'
```

To print every HTTP request and response in full, uncomment the above
line. This functionality is provided by Anthropic’s SDK.

<div>

> **Tip**
>
> If you’re reading the rendered version of this notebook, you’ll see an
> “Exported source” collapsible widget below. If you’re reading the
> source notebook directly, you’ll see `#| exports` at the top of the
> cell. These show that this piece of code will be exported into the
> python module that this notebook creates. No other code will be
> included – any other code in this notebook is just for demonstration,
> documentation, and testing.
>
> You can toggle expanding/collapsing the source code of all exported
> sections by using the `</> Code` menu in the top right of the rendered
> notebook page.

</div>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
models = 'claude-3-opus-20240229','claude-3-5-sonnet-20240620','claude-3-haiku-20240307'
```

</details>

These are the current versions of Anthropic’s model at the time of
writing.

``` python
model = models[1]
```

For examples, we’ll use Sonnet 3.5, since it’s awesome.

## Antropic SDK

``` python
cli = Anthropic()
```

This is what Anthropic’s SDK provides for interacting with Python. To
use it, pass it a list of *messages*, with *content* and a *role*. The
roles should alternate between *user* and *assistant*.

<div>

> **Tip**
>
> After the code below you’ll see an indented section with an orange
> vertical line on the left. This is used to show the *result* of
> running the code above. Because the code is running in a Jupyter
> Notebook, we don’t have to use `print` to display results, we can just
> type the expression directly, as we do with `r` here.

</div>

``` python
m = {'role': 'user', 'content': "I'm Jeremy"}
r = cli.messages.create(messages=[m], model=model, max_tokens=100)
r
```

    Message(id='msg_019qLJxay5HTSe8krZkYDgoV', content=[TextBlock(text="Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?", type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=Usage(input_tokens=10, output_tokens=23))

### Formatting output

That output is pretty long and hard to read, so let’s clean it up. We’ll
start by pulling out the `Content` part of the message. To do that,
we’re going to write our first function which will be included to the
`claudette/core.py` module.

<div>

> **Tip**
>
> This is the first exported public function or class we’re creating
> (the previous export was of a variable). In the rendered version of
> the notebook for these you’ll see 4 things, in this order (unless the
> symbol starts with a single `_`, which indicates it’s *private*):
>
> - The signature (with the symbol name as a heading, with a horizontal
>   rule above)
> - A table of paramater docs (if provided)
> - The doc string (in italics).
> - The source code (in a collapsible “Exported source” block)
>
> After that, we generally provide a bit more detail on what we’ve
> created, and why, along with a sample usage.

</div>

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L31"
target="_blank" style="float:right; font-size:smaller">source</a>

### find_block

>      find_block (r:collections.abc.Mapping, blk_type:type=<class
>                  'anthropic.types.text_block.TextBlock'>)

*Find the first block of type `blk_type` in `r.content`.*

<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td>Mapping</td>
<td></td>
<td>The message to look in</td>
</tr>
<tr class="even">
<td>blk_type</td>
<td>type</td>
<td>TextBlock</td>
<td>The type of block to find</td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def find_block(r:abc.Mapping, # The message to look in
               blk_type:type=TextBlock  # The type of block to find
              ):
    "Find the first block of type `blk_type` in `r.content`."
    return first(o for o in r.content if isinstance(o,blk_type))
```

</details>

This makes it easier to grab the needed parts of Claude’s responses,
which can include multiple pieces of content. By default, we look for
the first text block. That will generally have the content we want to
display.

``` python
find_block(r)
```

    TextBlock(text="Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?", type='text')

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L38"
target="_blank" style="float:right; font-size:smaller">source</a>

### contents

>      contents (r)

*Helper to get the contents from Claude response `r`.*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def contents(r):
    "Helper to get the contents from Claude response `r`."
    blk = find_block(r)
    if not blk and r.content: blk = r.content[0]
    return blk.text.strip() if hasattr(blk,'text') else blk
```

</details>

For display purposes, we often just want to show the text itself.

``` python
contents(r)
```

    "Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?"

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def _repr_markdown_(self:(Message)):
    det = '\n- '.join(f'{k}: `{v}`' for k,v in self.model_dump().items())
    return f"""{contents(self)}

<details>

- {det}

</details>"""
```

</details>

Jupyter looks for a `_repr_markdown_` method in displayed objects; we
add this in order to display just the content text, and collapse full
details into a hideable section. Note that `patch` is from
[fastcore](https://fastcore.fast.ai/), and is used to add (or replace)
functionality in an existing class. We pass the class(es) that we want
to patch as type annotations to `self`. In this case, `_repr_markdown_`
is being added to Anthropic’s `Message` class, so when we display the
message now we just see the contents, and the details are hidden away in
a collapsible details block.

``` python
r
```

Hello Jeremy! It’s nice to meet you. Is there anything I can help you
with today?

<details>

- id: `msg_019qLJxay5HTSe8krZkYDgoV`
- content:
  `[{'text': "Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage: `{'input_tokens': 10, 'output_tokens': 23}`

</details>

One key part of the response is the
[`usage`](https://claudette.answer.ai/core.html#usage) key, which tells
us how many tokens we used by returning a `Usage` object.

We’ll add some helpers to make things a bit cleaner for creating and
formatting these objects.

``` python
r.usage
```

    Usage(input_tokens=10, output_tokens=23)

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L57"
target="_blank" style="float:right; font-size:smaller">source</a>

### usage

>      usage (inp=0, out=0)

*Slightly more concise version of `Usage`.*

<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>inp</td>
<td>int</td>
<td>0</td>
<td>Number of input tokens</td>
</tr>
<tr class="even">
<td>out</td>
<td>int</td>
<td>0</td>
<td>Number of output tokens</td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def usage(inp=0, # Number of input tokens
          out=0  # Number of output tokens
         ):
    "Slightly more concise version of `Usage`."
    return Usage(input_tokens=inp, output_tokens=out)
```

</details>

The constructor provided by Anthropic is rather verbose, so we clean it
up a bit, using a lowercase version of the name.

``` python
usage(5)
```

    Usage(input_tokens=5, output_tokens=0)

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L65"
target="_blank" style="float:right; font-size:smaller">source</a>

### Usage.total

>      Usage.total ()

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch(as_prop=True)
def total(self:Usage): return self.input_tokens+self.output_tokens
```

</details>

Adding a `total` property to `Usage` makes it easier to see how many
tokens we’ve used up altogether.

``` python
usage(5,1).total
```

    6

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L69"
target="_blank" style="float:right; font-size:smaller">source</a>

### Usage.\_\_repr\_\_

>      Usage.__repr__ ()

*Return repr(self).*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def __repr__(self:Usage): return f'In: {self.input_tokens}; Out: {self.output_tokens}; Total: {self.total}'
```

</details>

In python, patching `__repr__` lets us change how an object is
displayed. (More generally, methods starting and ending in `__` in
Python are called `dunder` methods, and have some `magic` behavior –
such as, in this case, changing how an object is displayed.)

``` python
r.usage
```

    In: 10; Out: 23; Total: 33

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L73"
target="_blank" style="float:right; font-size:smaller">source</a>

### Usage.\_\_add\_\_

>      Usage.__add__ (b)

*Add together each of `input_tokens` and `output_tokens`*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def __add__(self:Usage, b):
    "Add together each of `input_tokens` and `output_tokens`"
    return usage(self.input_tokens+b.input_tokens, self.output_tokens+b.output_tokens)
```

</details>

And, patching `__add__` lets `+` work on a `Usage` object.

``` python
r.usage+r.usage
```

    In: 20; Out: 46; Total: 66

### Creating messages

Creating correctly formatted `dict`s from scratch every time isn’t very
handy, so next up we’ll add helpers for this.

``` python
def mk_msg(content, role='user', **kw):
    return dict(role=role, content=content, **kw)
```

We make things a bit more convenient by writing a function to create a
message for us.

<div>

> **Note**
>
> You may have noticed that we didn’t export the
> [`mk_msg`](https://claudette.answer.ai/core.html#mk_msg) function
> (i.e. there’s no “Exported source” block around it). That’s because
> we’ll need more functionality in our final version than this version
> has – so we’ll be defining a more complete version later. Rather than
> refactoring/editing in notebooks, often it’s helpful to simply
> gradually build up complexity by re-defining a symbol.

</div>

``` python
prompt = "I'm Jeremy"
m = mk_msg(prompt)
m
```

    {'role': 'user', 'content': "I'm Jeremy"}

``` python
r = cli.messages.create(messages=[m], model=model, max_tokens=100)
r
```

Hello Jeremy! It’s nice to meet you. How can I assist you today? Is
there anything specific you’d like to talk about or any questions you
have?

<details>

- id: `msg_017RAP4TephYyTFyKyfhsUxk`
- content:
  `[{'text': "Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage: `{'input_tokens': 10, 'output_tokens': 36}`

</details>

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L78"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_msgs

>      mk_msgs (msgs:list, **kw)

*Helper to set ‘assistant’ role on alternate messages.*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def mk_msgs(msgs:list, **kw):
    "Helper to set 'assistant' role on alternate messages."
    if isinstance(msgs,str): msgs=[msgs]
    return [mk_msg(o, ('user','assistant')[i%2], **kw) for i,o in enumerate(msgs)]
```

</details>

LLMs, including Claude, don’t actually have state, but instead dialogs
are created by passing back all previous prompts and responses every
time. With Claude, they always alternate *user* and *assistant*.
Therefore we create a function to make it easier to build up these
dialog lists.

But to do so, we need to update
[`mk_msg`](https://claudette.answer.ai/core.html#mk_msg) so that we
can’t only pass a `str` as `content`, but can also pass a `dict` or an
object with a `content` attr, since these are both types of message that
Claude can create. To do so, we check for a `content` key or attr, and
use it if found.

``` python
def mk_msg(content, role='user', **kw):
    "Helper to create a `dict` appropriate for a Claude message. `kw` are added as key/value pairs to the message"
    if hasattr(content, 'content'): content,role = content.content,content.role
    if isinstance(content, abc.Mapping): content=content['content']
    return dict(role=role, content=content, **kw)
```

``` python
msgs = mk_msgs([prompt, r, 'I forgot my name. Can you remind me please?'])
msgs
```

    [{'role': 'user', 'content': "I'm Jeremy"},
     {'role': 'assistant',
      'content': [TextBlock(text="Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?", type='text')]},
     {'role': 'user', 'content': 'I forgot my name. Can you remind me please?'}]

Now, if we pass this list of messages to Claude, the model treats it as
a conversation to respond to.

``` python
cli.messages.create(messages=msgs, model=model, max_tokens=200)
```

Of course! You just told me that your name is Jeremy.

<details>

- id: `msg_01YWeAebsvvgLXSfy1HgZbNK`
- content:
  `[{'text': 'Of course! You just told me that your name is Jeremy.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage: `{'input_tokens': 60, 'output_tokens': 16}`

</details>

## Client

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L84"
target="_blank" style="float:right; font-size:smaller">source</a>

### Client

>      Client (model, cli=None, log=False)

*Basic Anthropic messages client.*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
class Client:
    def __init__(self, model, cli=None, log=False):
        "Basic Anthropic messages client."
        self.model,self.use = model,usage()
        self.log = [] if log else None
        self.c = (cli or Anthropic(default_headers={'anthropic-beta': 'prompt-caching-2024-07-31'}))
```

</details>

We’ll create a simple
[`Client`](https://claudette.answer.ai/core.html#client) for `Anthropic`
which tracks usage stores the model to use. We don’t add any methods
right away – instead we’ll use `patch` for that so we can add and
document them incrementally.

``` python
c = Client(model)
c.use
```

    In: 0; Out: 0; Total: 0

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def _r(self:Client, r:Message, prefill=''):
    "Store the result of the message and accrue total usage."
    if prefill:
        blk = find_block(r)
        blk.text = prefill + (blk.text or '')
    self.result = r
    self.use += r.usage
    self.stop_reason = r.stop_reason
    self.stop_sequence = r.stop_sequence
    return r
```

</details>

We use a `_` prefix on private methods, but we document them here in the
interests of literate source code.

`_r` will be used each time we get a new result, to track usage and also
to keep the result available for later.

``` python
c._r(r)
c.use
```

    In: 10; Out: 36; Total: 46

Whereas OpenAI’s models use a `stream` parameter for streaming,
Anthropic’s use a separate method. We implement Anthropic’s approach in
a private method, and then use a `stream` parameter in `__call__` for
consistency:

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def _log(self:Client, final, prefill, msgs, maxtok=None, sp=None, temp=None, stream=None, stop=None, **kwargs):
    self._r(final, prefill)
    if self.log is not None: self.log.append({
        "msgs": msgs, "prefill": prefill, **kwargs,
        "msgs": msgs, "prefill": prefill, "maxtok": maxtok, "sp": sp, "temp": temp, "stream": stream, "stop": stop, **kwargs,
        "result": self.result, "use": self.use, "stop_reason": self.stop_reason, "stop_sequence": self.stop_sequence
    })
    return self.result
```

</details>
<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def _stream(self:Client, msgs:list, prefill='', **kwargs):
    with self.c.messages.stream(model=self.model, messages=mk_msgs(msgs), **kwargs) as s:
        if prefill: yield(prefill)
        yield from s.text_stream
        self._log(s.get_final_message(), prefill, msgs, **kwargs)
```

</details>

Claude supports adding an extra `assistant` message at the end, which
contains the *prefill* – i.e. the text we want Claude to assume the
response starts with. However Claude doesn’t actually repeat that in the
response, so for convenience we add it.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L137"
target="_blank" style="float:right; font-size:smaller">source</a>

### Client.\_\_call\_\_

>      Client.__call__ (msgs:list, sp='', temp=0, maxtok=4096, prefill='',
>                       stream:bool=False, stop=None, metadata:message_create_pa
>                       rams.Metadata|NotGiven=NOT_GIVEN,
>                       stop_sequences:List[str]|NotGiven=NOT_GIVEN, system:Unio
>                       n[str,Iterable[TextBlockParam]]|NotGiven=NOT_GIVEN,
>                       temperature:float|NotGiven=NOT_GIVEN, tool_choice:messag
>                       e_create_params.ToolChoice|NotGiven=NOT_GIVEN,
>                       tools:Iterable[ToolParam]|NotGiven=NOT_GIVEN,
>                       top_k:int|NotGiven=NOT_GIVEN,
>                       top_p:float|NotGiven=NOT_GIVEN,
>                       extra_headers:Headers|None=None,
>                       extra_query:Query|None=None, extra_body:Body|None=None,
>                       timeout:float|httpx.Timeout|None|NotGiven=NOT_GIVEN)

*Make a call to Claude.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>msgs</td>
<td>list</td>
<td></td>
<td>List of messages in the dialog</td>
</tr>
<tr class="even">
<td>sp</td>
<td>str</td>
<td></td>
<td>The system prompt</td>
</tr>
<tr class="odd">
<td>temp</td>
<td>int</td>
<td>0</td>
<td>Temperature</td>
</tr>
<tr class="even">
<td>maxtok</td>
<td>int</td>
<td>4096</td>
<td>Maximum tokens</td>
</tr>
<tr class="odd">
<td>prefill</td>
<td>str</td>
<td></td>
<td>Optional prefill to pass to Claude as start of its response</td>
</tr>
<tr class="even">
<td>stream</td>
<td>bool</td>
<td>False</td>
<td>Stream response?</td>
</tr>
<tr class="odd">
<td>stop</td>
<td>NoneType</td>
<td>None</td>
<td>Stop sequence</td>
</tr>
<tr class="even">
<td>metadata</td>
<td>message_create_params.Metadata | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr class="odd">
<td>stop_sequences</td>
<td>List[str] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr class="even">
<td>system</td>
<td>Union[str, Iterable[TextBlockParam]] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr class="odd">
<td>temperature</td>
<td>float | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr class="even">
<td>tool_choice</td>
<td>message_create_params.ToolChoice | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr class="odd">
<td>tools</td>
<td>Iterable[ToolParam] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr class="even">
<td>top_k</td>
<td>int | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr class="odd">
<td>top_p</td>
<td>float | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr class="even">
<td>extra_headers</td>
<td>Headers | None</td>
<td>None</td>
<td></td>
</tr>
<tr class="odd">
<td>extra_query</td>
<td>Query | None</td>
<td>None</td>
<td></td>
</tr>
<tr class="even">
<td>extra_body</td>
<td>Body | None</td>
<td>None</td>
<td></td>
</tr>
<tr class="odd">
<td>timeout</td>
<td>float | httpx.Timeout | None | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def _precall(self:Client, msgs, prefill, stop, kwargs):
    pref = [prefill.strip()] if prefill else []
    if not isinstance(msgs,list): msgs = [msgs]
    if stop is not None:
        if not isinstance(stop, (list)): stop = [stop]
        kwargs["stop_sequences"] = stop
    msgs = mk_msgs(msgs+pref)
    return msgs
```

</details>
<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
@delegates(messages.Messages.create)
def __call__(self:Client,
             msgs:list, # List of messages in the dialog
             sp='', # The system prompt
             temp=0, # Temperature
             maxtok=4096, # Maximum tokens
             prefill='', # Optional prefill to pass to Claude as start of its response
             stream:bool=False, # Stream response?
             stop=None, # Stop sequence
             **kwargs):
    "Make a call to Claude."
    msgs = self._precall(msgs, prefill, stop, kwargs)
    if stream: return self._stream(msgs, prefill=prefill, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)
    res = self.c.messages.create(
        model=self.model, messages=msgs, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)
    return self._log(res, prefill, msgs, maxtok, sp, temp, stream=stream, stop=stop, **kwargs)
```

</details>

Defining `__call__` let’s us use an object like a function (i.e it’s
*callable*). We use it as a small wrapper over `messages.create`.

``` python
c = Client(model, log=True)
c.use
```

    In: 0; Out: 0; Total: 0

``` python
c.model = models[-1]
```

``` python
c('Hi')
```

Hello! How can I assist you today?

<details>

- id: `msg_01ADNqsrkyiEoMpqQy8WY8DC`
- content:
  `[{'text': 'Hello! How can I assist you today?', 'type': 'text'}]`
- model: `claude-3-haiku-20240307`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 8, 'output_tokens': 12, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

``` python
c.use
```

    In: 8; Out: 12; Total: 20

Let’s try out *prefill*:

``` python
q = "Concisely, what is the meaning of life?"
pref = 'According to Douglas Adams,'
```

``` python
c(q, prefill=pref)
```

According to Douglas Adams, “The answer to the ultimate question of
life, the universe, and everything is 42.”

<details>

- id: `msg_01RxVtMH3djiS3pRc8Do2SFA`
- content:
  `[{'text': 'According to Douglas Adams,  "The answer to the ultimate question of life, the universe, and everything is 42."', 'type': 'text'}]`
- model: `claude-3-haiku-20240307`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 24, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

We can pass `stream=True` to stream the response back incrementally:

``` python
for o in c('Hi', stream=True): print(o, end='')
```

    Hello! How can I assist you today?

``` python
c.use
```

    In: 40; Out: 47; Total: 87

``` python
for o in c(q, prefill=pref, stream=True): print(o, end='')
```

    According to Douglas Adams,  "The answer to the ultimate question of life, the universe, and everything is 42."

``` python
c.use
```

    In: 64; Out: 70; Total: 134

Pass a stop seauence if you want claude to stop generating text when it
encounters it.

``` python
c("Count from 1 to 10", stop="5")
```

1, 2, 3, 4,

<details>

- id: `msg_013P6ntb5vP2XGwUdDrAcxSP`
- content: `[{'text': '1, 2, 3, 4, ', 'type': 'text'}]`
- model: `claude-3-haiku-20240307`
- role: `assistant`
- stop_reason: `stop_sequence`
- stop_sequence: `5`
- type: `message`
- usage:
  `{'input_tokens': 15, 'output_tokens': 14, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

This also works with streaming, and you can pass more than one stop
sequence:

``` python
for o in c("Count from 1 to 10", stop=["2", "yellow"], stream=True):
    print(o, end='')
print(c.stop_reason, c.stop_sequence)
```

    1, stop_sequence 2

You can check the logs:

``` python
c.log[-1]
```

    {'msgs': [{'role': 'user', 'content': 'Count from 1 to 10'}],
     'prefill': '',
     'max_tokens': 4096,
     'system': '',
     'temperature': 0,
     'stop_sequences': ['2', 'yellow'],
     'maxtok': None,
     'sp': None,
     'temp': None,
     'stream': None,
     'stop': None,
     'result': Message(id='msg_01Mcd8Mxnw3zMwtUy1y5Q1gf', content=[TextBlock(text='1, ', type='text')], model='claude-3-haiku-20240307', role='assistant', stop_reason='stop_sequence', stop_sequence='2', type='message', usage=In: 15; Out: 5; Total: 20),
     'use': In: 94; Out: 89; Total: 183,
     'stop_reason': 'stop_sequence',
     'stop_sequence': '2'}

## Tool use

Let’s now add tool use (aka *function calling*).

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L154"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_tool_choice

>      mk_tool_choice (choose:Union[str,bool,NoneType])

*Create a `tool_choice` dict that’s ‘auto’ if `choose` is `None`, ‘any’
if it is True, or ‘tool’ otherwise*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def mk_tool_choice(choose:Union[str,bool,None])->dict:
    "Create a `tool_choice` dict that's 'auto' if `choose` is `None`, 'any' if it is True, or 'tool' otherwise"
    return {"type": "tool", "name": choose} if isinstance(choose,str) else {'type':'any'} if choose else {'type':'auto'}
```

</details>

``` python
print(mk_tool_choice('sums'))
print(mk_tool_choice(True))
print(mk_tool_choice(None))
```

    {'type': 'tool', 'name': 'sums'}
    {'type': 'any'}
    {'type': 'auto'}

Claude can be forced to use a particular tool, or select from a specific
list of tools, or decide for itself when to use a tool. If you want to
force a tool (or force choosing from a list), include a `tool_choice`
param with a dict from
[`mk_tool_choice`](https://claudette.answer.ai/core.html#mk_tool_choice).

For testing, we need a function that Claude can call; we’ll write a
simple function that adds numbers together, and will tell us when it’s
being called:

``` python
def sums(
    a:int,  # First thing to sum
    b:int=1 # Second thing to sum
) -> int: # The sum of the inputs
    "Adds a + b."
    print(f"Finding the sum of {a} and {b}")
    return a + b
```

``` python
a,b = 604542,6458932
pr = f"What is {a}+{b}?"
sp = "You are a summing expert."
```

Claudette can autogenerate a schema thanks to the `toolslm` library.
We’ll force the use of the tool using the function we created earlier.

``` python
tools=[get_schema(sums)]
choice = mk_tool_choice('sums')
```

We’ll start a dialog with Claude now. We’ll store the messages of our
dialog in `msgs`. The first message will be our prompt `pr`, and we’ll
pass our `tools` schema.

``` python
msgs = mk_msgs(pr)
r = c(msgs, sp=sp, tools=tools, tool_choice=choice)
r
```

ToolUseBlock(id=‘toolu_01KZ2VpnTQmG26UzfAotM98g’, input={‘a’: 604542,
‘b’: 6458932}, name=‘sums’, type=‘tool_use’)

<details>

- id: `msg_013KmnCBTXC1kJmefF9LfF3d`
- content:
  `[{'id': 'toolu_01KZ2VpnTQmG26UzfAotM98g', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]`
- model: `claude-3-haiku-20240307`
- role: `assistant`
- stop_reason: `tool_use`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 493, 'output_tokens': 53, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

When Claude decides that it should use a tool, it passes back a
`ToolUseBlock` with the name of the tool to call, and the params to use.

We don’t want to allow it to call just any possible function (that would
be a security disaster!) so we create a *namespace* – that is, a
dictionary of allowable function names to call.

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _mk_ns(*funcs:list[callable]) -> dict[str,callable]:
    "Create a `dict` of name to function in `funcs`, to use as a namespace"
    return {f.__name__:f for f in funcs}
```

</details>

``` python
ns = _mk_ns(sums)
ns
```

    {'sums': <function __main__.sums(a: int, b: int = 1) -> int>}

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L176"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_funcres

>      mk_funcres (tuid, res)

*Given tool use id and the tool result, create a tool_result response.*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def call_func(fc:ToolUseBlock, # Tool use block from Claude's message
              ns:Optional[abc.Mapping]=None, # Namespace to search for tools, defaults to `globals()`
              obj:Optional=None # Object to search for tools
             ):
    "Call the function in the tool response `tr`, using namespace `ns`."
    if ns is None: ns=globals()
    if not isinstance(ns, abc.Mapping): ns = _mk_ns(*ns)
    func = getattr(obj, fc.name, None)
    if not func: func = ns[fc.name]
    res = func(**fc.input)
    return res

def mk_funcres(tuid, res):
    "Given tool use id and the tool result, create a tool_result response."
    return dict(type="tool_result", tool_use_id=tuid, content=str(res))
```

</details>

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L164"
target="_blank" style="float:right; font-size:smaller">source</a>

### call_func

>      call_func (fc:anthropic.types.tool_use_block.ToolUseBlock,
>                 ns:Optional[collections.abc.Mapping]=None, obj:Optional=None)

*Call the function in the tool response `tr`, using namespace `ns`.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fc</td>
<td>ToolUseBlock</td>
<td></td>
<td>Tool use block from Claude’s message</td>
</tr>
<tr class="even">
<td>ns</td>
<td>Optional</td>
<td>None</td>
<td>Namespace to search for tools, defaults to
<code>globals()</code></td>
</tr>
<tr class="odd">
<td>obj</td>
<td>Optional</td>
<td>None</td>
<td>Object to search for tools</td>
</tr>
</tbody>
</table>

We can now use the function requested by Claude. We look it up in `ns`,
and pass in the provided parameters.

``` python
fc = find_block(r, ToolUseBlock)
res = mk_funcres(fc.id, call_func(fc, ns=ns))
res
```

    Finding the sum of 604542 and 6458932

    {'type': 'tool_result',
     'tool_use_id': 'toolu_01KZ2VpnTQmG26UzfAotM98g',
     'content': '7063474'}

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L181"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_toolres

>      mk_toolres (r:collections.abc.Mapping,
>                  ns:Optional[collections.abc.Mapping]=None, obj:Optional=None)

*Create a `tool_result` message from response `r`.*

<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td>Mapping</td>
<td></td>
<td>Tool use request response from Claude</td>
</tr>
<tr class="even">
<td>ns</td>
<td>Optional</td>
<td>None</td>
<td>Namespace to search for tools</td>
</tr>
<tr class="odd">
<td>obj</td>
<td>Optional</td>
<td>None</td>
<td>Class to search for tools</td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def mk_toolres(
    r:abc.Mapping, # Tool use request response from Claude
    ns:Optional[abc.Mapping]=None, # Namespace to search for tools
    obj:Optional=None # Class to search for tools
    ):
    "Create a `tool_result` message from response `r`."
    cts = getattr(r, 'content', [])
    res = [mk_msg(r)]
    tcs = [mk_funcres(o.id, call_func(o, ns=ns, obj=obj)) for o in cts if isinstance(o,ToolUseBlock)]
    if tcs: res.append(mk_msg(tcs))
    return res
```

</details>

In order to tell Claude the result of the tool call, we pass back the
tool use assistant request and the `tool_result` response.

``` python
tr = mk_toolres(r, ns=ns)
tr
```

    Finding the sum of 604542 and 6458932

    [{'role': 'assistant',
      'content': [ToolUseBlock(id='toolu_01KZ2VpnTQmG26UzfAotM98g', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')]},
     {'role': 'user',
      'content': [{'type': 'tool_result',
        'tool_use_id': 'toolu_01KZ2VpnTQmG26UzfAotM98g',
        'content': '7063474'}]}]

We add this to our dialog, and now Claude has all the information it
needs to answer our question.

``` python
msgs += tr
contents(c(msgs, sp=sp, tools=tools))
```

    'The sum of 604542 and 6458932 is 7063474.'

This works with methods as well – in this case, use the object itself
for `ns`:

``` python
class Dummy:
    def sums(
        self,
        a:int,  # First thing to sum
        b:int=1 # Second thing to sum
    ) -> int: # The sum of the inputs
        "Adds a + b."
        print(f"Finding the sum of {a} and {b}")
        return a + b
```

``` python
tools = [get_schema(Dummy.sums)]
o = Dummy()

msgs = mk_msgs(pr)
r = c(msgs, sp=sp, tools=tools, tool_choice=choice)
tr = mk_toolres(r, obj=o)
msgs += tr
contents(c(msgs, sp=sp, tools=tools))
```

    Finding the sum of 604542 and 6458932

    'The sum of 604542 and 6458932 is 7063474.'

## Chat

Rather than manually adding the responses to a dialog, we’ll create a
simple [`Chat`](https://claudette.answer.ai/core.html#chat) class to do
that for us, each time we make a request. We’ll also store the system
prompt and tools here, to avoid passing them every time.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L194"
target="_blank" style="float:right; font-size:smaller">source</a>

### Chat

>      Chat (model:Optional[str]=None, cli:Optional[__main__.Client]=None,
>            sp='', tools:Optional[list]=None, cont_pr:Optional[str]=None,
>            tool_choice:Optional[dict]=None)

*Anthropic chat client.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>model</td>
<td>Optional</td>
<td>None</td>
<td>Model to use (leave empty if passing <code>cli</code>)</td>
</tr>
<tr class="even">
<td>cli</td>
<td>Optional</td>
<td>None</td>
<td>Client to use (leave empty if passing <code>model</code>)</td>
</tr>
<tr class="odd">
<td>sp</td>
<td>str</td>
<td></td>
<td>Optional system prompt</td>
</tr>
<tr class="even">
<td>tools</td>
<td>Optional</td>
<td>None</td>
<td>List of tools to make available to Claude</td>
</tr>
<tr class="odd">
<td>cont_pr</td>
<td>Optional</td>
<td>None</td>
<td>User prompt to continue an assistant response:
assistant,[user:“…”],assistant</td>
</tr>
<tr class="even">
<td>tool_choice</td>
<td>Optional</td>
<td>None</td>
<td>Optionally force use of some tool</td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
class Chat:
    def __init__(self,
                 model:Optional[str]=None, # Model to use (leave empty if passing `cli`)
                 cli:Optional[Client]=None, # Client to use (leave empty if passing `model`)
                 sp='', # Optional system prompt
                 tools:Optional[list]=None, # List of tools to make available to Claude
                 cont_pr:Optional[str]=None, # User prompt to continue an assistant response: assistant,[user:"..."],assistant
                 tool_choice:Optional[dict]=None): # Optionally force use of some tool
        "Anthropic chat client."
        assert model or cli
        assert cont_pr != "", "cont_pr may not be an empty string"
        self.c = (cli or Client(model))
        self.h,self.sp,self.tools,self.cont_pr,self.tool_choice = [],sp,tools,cont_pr,tool_choice

    @property
    def use(self): return self.c.use
```

</details>

The class stores the
[`Client`](https://claudette.answer.ai/core.html#client) that will
provide the responses in `c`, and a history of messages in `h`.

``` python
sp = "Never mention what tools you use."
chat = Chat(model, sp=sp)
chat.c.use, chat.h
```

    (In: 0; Out: 0; Total: 0, [])

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L237"
target="_blank" style="float:right; font-size:smaller">source</a>

### Chat.\_\_call\_\_

>      Chat.__call__ (pr=None, temp=0, maxtok=4096, stream=False, prefill='',
>                     **kw)

*Call self as a function.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pr</td>
<td>NoneType</td>
<td>None</td>
<td>Prompt / message</td>
</tr>
<tr class="even">
<td>temp</td>
<td>int</td>
<td>0</td>
<td>Temperature</td>
</tr>
<tr class="odd">
<td>maxtok</td>
<td>int</td>
<td>4096</td>
<td>Maximum tokens</td>
</tr>
<tr class="even">
<td>stream</td>
<td>bool</td>
<td>False</td>
<td>Stream response?</td>
</tr>
<tr class="odd">
<td>prefill</td>
<td>str</td>
<td></td>
<td>Optional prefill to pass to Claude as start of its response</td>
</tr>
<tr class="even">
<td>kw</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def _stream(self:Chat, res):
    yield from res
    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)
```

</details>
<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def _post_pr(self:Chat, pr, prev_role):
    if pr is None and prev_role == 'assistant':
        if self.cont_pr is None:
            raise ValueError("Prompt must be given after assistant completion, or use `self.cont_pr`.")
        pr = self.cont_pr # No user prompt, keep the chain
    if pr: self.h.append(mk_msg(pr))
```

</details>
<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def _append_pr(self:Chat,
               pr=None,  # Prompt / message
              ):
    prev_role = nested_idx(self.h, -1, 'role') if self.h else 'assistant' # First message should be 'user'
    if pr and prev_role == 'user': self() # already user request pending
    self._post_pr(pr, prev_role)
```

</details>
<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
def __call__(self:Chat,
             pr=None,  # Prompt / message
             temp=0, # Temperature
             maxtok=4096, # Maximum tokens
             stream=False, # Stream response?
             prefill='', # Optional prefill to pass to Claude as start of its response
             **kw):
    self._append_pr(pr)
    if self.tools: kw['tools'] = [get_schema(o) for o in self.tools]
    if self.tool_choice and pr: kw['tool_choice'] = mk_tool_choice(self.tool_choice)
    res = self.c(self.h, stream=stream, prefill=prefill, sp=self.sp, temp=temp, maxtok=maxtok, **kw)
    if stream: return self._stream(res)
    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)
    return res
```

</details>

The `__call__` method just passes the request along to the
[`Client`](https://claudette.answer.ai/core.html#client), but rather
than just passing in this one prompt, it appends it to the history and
passes it all along. As a result, we now have state!

``` python
chat("I'm Jeremy")
chat("What's my name?")
```

Your name is Jeremy.

<details>

- id: `msg_01DJHYAMYuC7TQSdMCmeQiaq`
- content: `[{'text': 'Your name is Jeremy.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 235, 'output_tokens': 8, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

Let’s try out prefill too:

``` python
q = "Concisely, what is the meaning of life?"
pref = 'According to Douglas Adams,'
```

``` python
chat(q, prefill=pref)
```

According to Douglas Adams, the meaning of life is 42. More seriously,
there’s no universally agreed upon answer. Common philosophical
perspectives include:

1.  Finding personal fulfillment
2.  Serving others
3.  Pursuing happiness
4.  Creating meaning through our choices
5.  Experiencing and appreciating existence

Ultimately, many believe each individual must determine their own life’s
meaning.

<details>

- id: `msg_01PLpsyGYqjVTMnvtGqzh1qD`
- content:
  `[{'text': "According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common philosophical perspectives include:\n\n1. Finding personal fulfillment\n2. Serving others\n3. Pursuing happiness\n4. Creating meaning through our choices\n5. Experiencing and appreciating existence\n\nUltimately, many believe each individual must determine their own life's meaning.", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 263, 'output_tokens': 82, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

By default messages must be in user, assistant, user format. If this
isn’t followed (aka calling `chat()` without a user message) it will
error out:

``` python
try: chat()
except ValueError as e: print("Error:", e)
```

    Error: Prompt must be given after assistant completion, or use `self.cont_pr`.

Setting `cont_pr` allows a “default prompt” to be specified when a
prompt isn’t specified. Usually used to prompt the model to continue.

``` python
chat.cont_pr = "keep going..."
chat()
```

Continuing on the topic of the meaning of life:

6.  Achieving self-actualization
7.  Leaving a positive legacy
8.  Connecting with others and forming relationships
9.  Pursuing knowledge and understanding
10. Embracing spiritual or religious beliefs
11. Overcoming challenges and growing as a person
12. Contributing to the advancement of humanity
13. Finding balance and harmony in life
14. Expressing creativity and individuality
15. Experiencing love in its various forms

These perspectives often overlap and can be combined in various ways.
The search for meaning itself is considered by some to be an essential
part of the human experience.

<details>

- id: `msg_0195oiRnvGTs64CCiQrESVn4`
- content:
  `[{'text': 'Continuing on the topic of the meaning of life:\n\n6. Achieving self-actualization\n7. Leaving a positive legacy\n8. Connecting with others and forming relationships\n9. Pursuing knowledge and understanding\n10. Embracing spiritual or religious beliefs\n11. Overcoming challenges and growing as a person\n12. Contributing to the advancement of humanity\n13. Finding balance and harmony in life\n14. Expressing creativity and individuality\n15. Experiencing love in its various forms\n\nThese perspectives often overlap and can be combined in various ways. The search for meaning itself is considered by some to be an essential part of the human experience.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 351, 'output_tokens': 139, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

You can see that the continue prompt is injected to keep the
user,assistant going.

``` python
chat.h[-3:]
```

    [{'role': 'assistant',
      'content': [TextBlock(text="According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common philosophical perspectives include:\n\n1. Finding personal fulfillment\n2. Serving others\n3. Pursuing happiness\n4. Creating meaning through our choices\n5. Experiencing and appreciating existence\n\nUltimately, many believe each individual must determine their own life's meaning.", type='text')]},
     {'role': 'user', 'content': 'keep going...'},
     {'role': 'assistant',
      'content': [TextBlock(text='Continuing on the topic of the meaning of life:\n\n6. Achieving self-actualization\n7. Leaving a positive legacy\n8. Connecting with others and forming relationships\n9. Pursuing knowledge and understanding\n10. Embracing spiritual or religious beliefs\n11. Overcoming challenges and growing as a person\n12. Contributing to the advancement of humanity\n13. Finding balance and harmony in life\n14. Expressing creativity and individuality\n15. Experiencing love in its various forms\n\nThese perspectives often overlap and can be combined in various ways. The search for meaning itself is considered by some to be an essential part of the human experience.', type='text')]}]

We can also use streaming:

``` python
chat = Chat(model, sp=sp)
for o in chat("I'm Jeremy", stream=True): print(o, end='')
```

    Hello Jeremy! It's nice to meet you. How are you doing today? Is there anything in particular you'd like to chat about or any questions I can help you with?

``` python
for o in chat(q, prefill=pref, stream=True): print(o, end='')
```

    According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common perspectives include:

    1. Finding personal fulfillment
    2. Serving others
    3. Pursuing knowledge
    4. Experiencing love and relationships
    5. Creating or appreciating art
    6. Achieving goals
    7. Living according to religious or spiritual beliefs

    Ultimately, many philosophers argue that each individual must determine their own meaning.

### Chat tool use

We automagically get streamlined tool use as well:

``` python
pr = f"What is {a}+{b}?"
pr
```

    'What is 604542+6458932?'

``` python
chat = Chat(model, sp=sp, tools=[sums])
r = chat(pr)
r
```

    Finding the sum of 604542 and 6458932

To answer this question, I can use the “sums” function to add these two
numbers together. Let me do that for you.

<details>

- id: `msg_01S2onXQ4zAtGJ4ZWzBf2Nba`
- content:
  `[{'text': 'To answer this question, I can use the "sums" function to add these two numbers together. Let me do that for you.', 'type': 'text'}, {'id': 'toolu_01PTAt1do4WtDkhszUupaoRK', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `tool_use`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 428, 'output_tokens': 101, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

``` python
chat()
```

The sum of 604542 and 6458932 is 7063474.

<details>

- id: `msg_01KYftq2WktJjfJJ6ikymqDQ`
- content:
  `[{'text': 'The sum of 604542 and 6458932 is 7063474.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 543, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

It should be correct, because it actually used our Python function to do
the addition. Let’s check:

``` python
a+b
```

    7063474

## Images

Claude can handle image data as well. As everyone knows, when testing
image APIs you have to use a cute puppy.

``` python
# Image is Cute_dog.jpg from Wikimedia
fn = Path('samples/puppy.jpg')
display.Image(filename=fn, width=200)
```

<img src="00_core_files/figure-commonmark/cell-98-output-1.jpeg"
width="200" />

``` python
img = fn.read_bytes()
```

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _add_cache(d, cache):
    "Optionally add cache control"
    if cache: d["cache_control"] = {"type": "ephemeral"}
    return d
```

</details>

Claude supports context caching by adding a `cache_control` header, so
we provide an option to enable that.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L259"
target="_blank" style="float:right; font-size:smaller">source</a>

### img_msg

>      img_msg (data:bytes, cache=False)

*Convert image `data` into an encoded `dict`*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def img_msg(data:bytes, cache=False)->dict:
    "Convert image `data` into an encoded `dict`"
    img = base64.b64encode(data).decode("utf-8")
    mtype = mimetypes.types_map['.'+imghdr.what(None, h=data)]
    r = dict(type="base64", media_type=mtype, data=img)
    return _add_cache({"type": "image", "source": r}, cache)
```

</details>

Anthropic have documented the particular `dict` structure that expect
image data to be in, so we have a little function to create that for us.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L267"
target="_blank" style="float:right; font-size:smaller">source</a>

### text_msg

>      text_msg (s:str, cache=False)

*Convert `s` to a text message*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def text_msg(s:str, cache=False)->dict:
    "Convert `s` to a text message"
    return _add_cache({"type": "text", "text": s}, cache)
```

</details>

A Claude message can be a list of image and text parts. So we’ve also
created a helper for making the text parts.

``` python
q = "In brief, what color flowers are in this image?"
msg = mk_msg([img_msg(img), text_msg(q)])
```

``` python
c([msg])
```

The image contains purple or lavender-colored flowers, which appear to
be daisies or a similar type of flower.

<details>

- id: `msg_01J7xj3C8LreZL78x6jghP9u`
- content:
  `[{'text': 'The image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.', 'type': 'text'}]`
- model: `claude-3-haiku-20240307`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 110, 'output_tokens': 28, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>
<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _mk_content(src, cache=False):
    "Create appropriate content data structure based on type of content"
    if isinstance(src,str): return text_msg(src, cache=cache)
    if isinstance(src,bytes): return img_msg(src, cache=cache)
    return src
```

</details>

There’s not need to manually choose the type of message, since we figure
that out from the data of the source data.

``` python
_mk_content('Hi')
```

    {'type': 'text', 'text': 'Hi'}

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/claudette/blob/main/claudette/core.py#L279"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_msg

>      mk_msg (content, role='user', cache=False, **kw)

*Helper to create a `dict` appropriate for a Claude message. `kw` are
added as key/value pairs to the message*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>content</td>
<td></td>
<td></td>
<td>A string, list, or dict containing the contents of the message</td>
</tr>
<tr class="even">
<td>role</td>
<td>str</td>
<td>user</td>
<td>Must be ‘user’ or ‘assistant’</td>
</tr>
<tr class="odd">
<td>cache</td>
<td>bool</td>
<td>False</td>
<td></td>
</tr>
<tr class="even">
<td>kw</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def mk_msg(content, # A string, list, or dict containing the contents of the message
           role='user', # Must be 'user' or 'assistant'
           cache=False,
           **kw):
    "Helper to create a `dict` appropriate for a Claude message. `kw` are added as key/value pairs to the message"
    if hasattr(content, 'content'): content,role = content.content,content.role
    if isinstance(content, abc.Mapping): content=content.get('content', content)
    if not isinstance(content, list): content=[content]
    content = [_mk_content(o, cache if islast else False) for islast,o in loop_last(content)] if content else '.'
    return dict(role=role, content=content, **kw)
```

</details>

``` python
mk_msg(['hi', 'there'], cache=True)
```

    {'role': 'user',
     'content': [{'type': 'text', 'text': 'hi'},
      {'type': 'text', 'text': 'there', 'cache_control': {'type': 'ephemeral'}}]}

When we construct a message, we now use
[`_mk_content`](https://claudette.answer.ai/core.html#_mk_content) to
create the appropriate parts. Since a dialog contains multiple messages,
and a message can contain multiple content parts, to pass a single
message with multiple parts we have to use a list containing a single
list:

``` python
c([[img, q]])
```

The image contains purple or lavender-colored flowers, which appear to
be daisies or a similar type of flower.

<details>

- id: `msg_01DMPFL3DPjKLoarGA2wjni7`
- content:
  `[{'text': 'The image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.', 'type': 'text'}]`
- model: `claude-3-haiku-20240307`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 110, 'output_tokens': 28, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

<div>

> **Note**
>
> As promised (much!) earlier, we’ve now finally completed our
> definition of
> [`mk_msg`](https://claudette.answer.ai/core.html#mk_msg), and this
> version is the one we export to the Python module.

</div>

## Third party providers

### Amazon Bedrock

These are Amazon’s current Claude models:

We don’t need any extra code to support Amazon Bedrock – we just have to
set up the approach client:

``` python
ab = AnthropicBedrock(
    aws_access_key=os.environ['AWS_ACCESS_KEY'],
    aws_secret_key=os.environ['AWS_SECRET_KEY'],
)
client = Client(models_aws[-1], ab)
```

``` python
chat = Chat(cli=client)
```

``` python
chat("I'm Jeremy")
```

Hello Jeremy! It’s nice to meet you. How can I assist you today? Is
there anything specific you’d like to talk about or any questions you
have?

<details>

- id: `msg_bdrk_01MwjVA5hwyfob3w4vdsqpnU`
- content:
  `[{'text': "Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage: `{'input_tokens': 10, 'output_tokens': 36}`

</details>

### Google Vertex

``` python
from anthropic import AnthropicVertex
import google.auth
```

``` python
project_id = google.auth.default()[1]
region = "us-east5"
gv = AnthropicVertex(project_id=project_id, region=region)
client = Client(models_goog[-1], gv)
```

``` python
chat = Chat(cli=client)
```

``` python
chat("I'm Jeremy")
```

Hello Jeremy! It’s nice to meet you. How can I assist you today? Is
there anything specific you’d like to talk about or any questions you
have?

<details>

- id: `msg_vrtx_01PFtHewPDe35yShy7vecp5q`
- content:
  `[{'text': "Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage: `{'input_tokens': 10, 'output_tokens': 36}`

</details>
